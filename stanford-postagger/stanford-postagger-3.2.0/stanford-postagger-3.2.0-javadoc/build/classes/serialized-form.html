<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_33) on Thu Jun 20 16:29:01 PDT 2013 -->
<TITLE>
Serialized Form (Stanford JavaNLP API)
</TITLE>

<META NAME="date" CONTENT="2013-06-20">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Serialized Form (Stanford JavaNLP API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?serialized-form.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="serialized-form.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H1>
Serialized Form</H1>
</CENTER>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.international.morph</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.international.morph.MorphoFeatures"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/international/morph/MorphoFeatures.html" title="class in edu.stanford.nlp.international.morph">edu.stanford.nlp.international.morph.MorphoFeatures</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-3893316324305154940L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
fSpec</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>fSpec</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
altTag</H3>
<PRE>
java.lang.String <B>altTag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.international.morph.MorphoFeatureSpecification"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/international/morph/MorphoFeatureSpecification.html" title="class in edu.stanford.nlp.international.morph">edu.stanford.nlp.international.morph.MorphoFeatureSpecification</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5720683653931585664L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
activeFeatures</H3>
<PRE>
java.util.Set&lt;E&gt; <B>activeFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.io</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.io.RuntimeIOException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/io/RuntimeIOException.html" title="class in edu.stanford.nlp.io">edu.stanford.nlp.io.RuntimeIOException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8572218999165094626L

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.ling</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.ling.CategoryWordTag"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/CategoryWordTag.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.CategoryWordTag</A> extends <A HREF="edu/stanford/nlp/ling/StringLabel.html" title="class in edu.stanford.nlp.ling">StringLabel</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-745085381666943254L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
word</H3>
<PRE>
java.lang.String <B>word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tag</H3>
<PRE>
java.lang.String <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.ling.CoreLabel"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/CoreLabel.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.CoreLabel</A> extends <A HREF="edu/stanford/nlp/util/ArrayCoreMap.html" title="class in edu.stanford.nlp.util">ArrayCoreMap</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2L

<P>

<P>
<A NAME="edu.stanford.nlp.ling.LabeledWord"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.LabeledWord</A> extends <A HREF="edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7252006452127051085L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tag</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A> <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.ling.StringLabel"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/StringLabel.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.StringLabel</A> extends <A HREF="edu/stanford/nlp/ling/ValueLabel.html" title="class in edu.stanford.nlp.ling">ValueLabel</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4153619273767524247L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
str</H3>
<PRE>
java.lang.String <B>str</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
beginPosition</H3>
<PRE>
int <B>beginPosition</B></PRE>
<DL>
<DD>Start position of the word in the original input string
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
endPosition</H3>
<PRE>
int <B>endPosition</B></PRE>
<DL>
<DD>End position of the word in the original input string
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.ling.TaggedWord"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.TaggedWord</A> extends <A HREF="edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7252006452127051085L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tag</H3>
<PRE>
java.lang.String <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.ling.ValueLabel"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/ValueLabel.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.ValueLabel</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1413303679077285530L

<P>

<P>
<A NAME="edu.stanford.nlp.ling.Word"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.Word</A> extends <A HREF="edu/stanford/nlp/ling/StringLabel.html" title="class in edu.stanford.nlp.ling">StringLabel</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4817252915997034058L

<P>

<P>
<A NAME="edu.stanford.nlp.ling.WordLemmaTag"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/WordLemmaTag.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.WordLemmaTag</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5993410244163988138L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
word</H3>
<PRE>
java.lang.String <B>word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lemma</H3>
<PRE>
java.lang.String <B>lemma</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tag</H3>
<PRE>
java.lang.String <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.ling.WordTag"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/ling/WordTag.html" title="class in edu.stanford.nlp.ling">edu.stanford.nlp.ling.WordTag</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1859527239216813742L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
word</H3>
<PRE>
java.lang.String <B>word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tag</H3>
<PRE>
java.lang.String <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.math</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.math.ArrayMath.InvalidElementException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/math/ArrayMath.InvalidElementException.html" title="class in edu.stanford.nlp.math">edu.stanford.nlp.math.ArrayMath.InvalidElementException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1647150702529757545L

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.objectbank</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.objectbank.LineIterator.LineIteratorFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/objectbank/LineIterator.LineIteratorFactory.html" title="class in edu.stanford.nlp.objectbank">edu.stanford.nlp.objectbank.LineIterator.LineIteratorFactory</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
oper</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Function.html" title="interface in edu.stanford.nlp.util">Function</A>&lt;<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T1</A>,<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T2</A>&gt; <B>oper</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.objectbank.ObjectBank"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/objectbank/ObjectBank.html" title="class in edu.stanford.nlp.objectbank">edu.stanford.nlp.objectbank.ObjectBank</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4030295596701541770L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
rif</H3>
<PRE>
<A HREF="edu/stanford/nlp/objectbank/ReaderIteratorFactory.html" title="class in edu.stanford.nlp.objectbank">ReaderIteratorFactory</A> <B>rif</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
ifrf</H3>
<PRE>
<A HREF="edu/stanford/nlp/objectbank/IteratorFromReaderFactory.html" title="interface in edu.stanford.nlp.objectbank">IteratorFromReaderFactory</A>&lt;<A HREF="edu/stanford/nlp/objectbank/IteratorFromReaderFactory.html" title="type parameter in IteratorFromReaderFactory">T</A>&gt; <B>ifrf</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
contents</H3>
<PRE>
java.util.List&lt;E&gt; <B>contents</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
keepInMemory</H3>
<PRE>
boolean <B>keepInMemory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.optimization</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.optimization.QNMinimizer.SurpriseConvergence"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/optimization/QNMinimizer.SurpriseConvergence.html" title="class in edu.stanford.nlp.optimization">edu.stanford.nlp.optimization.QNMinimizer.SurpriseConvergence</A> extends java.lang.Throwable implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4290178321643529559L

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.parser.lexparser</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.AbstractDependencyGrammar"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/AbstractDependencyGrammar.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.AbstractDependencyGrammar</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>3L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;ois)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tagProjection</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TagProjection.html" title="interface in edu.stanford.nlp.parser.lexparser">TagProjection</A> <B>tagProjection</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>tagIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>wordIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numTagBins</H3>
<PRE>
int <B>numTagBins</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagBin</H3>
<PRE>
int[] <B>tagBin</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tlp</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreebankLanguagePack.html" title="interface in edu.stanford.nlp.trees">TreebankLanguagePack</A> <B>tlp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
directional</H3>
<PRE>
boolean <B>directional</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDistance</H3>
<PRE>
boolean <B>useDistance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCoarseDistance</H3>
<PRE>
boolean <B>useCoarseDistance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lex</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Lexicon.html" title="interface in edu.stanford.nlp.parser.lexparser">Lexicon</A> <B>lex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
stopTW</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/IntTaggedWord.html" title="class in edu.stanford.nlp.parser.lexparser">IntTaggedWord</A> <B>stopTW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wildTW</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/IntTaggedWord.html" title="class in edu.stanford.nlp.parser.lexparser">IntTaggedWord</A> <B>wildTW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
coarseDistanceBins</H3>
<PRE>
int[] <B>coarseDistanceBins</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
regDistanceBins</H3>
<PRE>
int[] <B>regDistanceBins</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
op</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Options.html" title="class in edu.stanford.nlp.parser.lexparser">Options</A> <B>op</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.AbstractTreebankParserParams"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/AbstractTreebankParserParams.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.AbstractTreebankParserParams</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4299501909017975915L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
evalGF</H3>
<PRE>
boolean <B>evalGF</B></PRE>
<DL>
<DD>If true, then evaluation is over grammatical functions as well as the labels
 If false, then grammatical functions are stripped for evaluation.  This really
 only makes sense if you've trained with grammatical functions but want to evaluate without them.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
inputEncoding</H3>
<PRE>
java.lang.String <B>inputEncoding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outputEncoding</H3>
<PRE>
java.lang.String <B>outputEncoding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tlp</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreebankLanguagePack.html" title="interface in edu.stanford.nlp.trees">TreebankLanguagePack</A> <B>tlp</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.AbstractTreebankParserParams.AnnotatePunctuationFunction"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/AbstractTreebankParserParams.AnnotatePunctuationFunction.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.AbstractTreebankParserParams.AnnotatePunctuationFunction</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
key</H3>
<PRE>
java.lang.String <B>key</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
annotationMark</H3>
<PRE>
java.lang.String <B>annotationMark</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.BaseLexicon"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/BaseLexicon.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.BaseLexicon</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>40L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;ois)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
uwModel</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/UnknownWordModel.html" title="interface in edu.stanford.nlp.parser.lexparser">UnknownWordModel</A> <B>uwModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
uwModelTrainerClass</H3>
<PRE>
java.lang.String <B>uwModelTrainerClass</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainOptions</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TrainOptions.html" title="class in edu.stanford.nlp.parser.lexparser">TrainOptions</A> <B>trainOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testOptions</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TestOptions.html" title="class in edu.stanford.nlp.parser.lexparser">TestOptions</A> <B>testOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
op</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Options.html" title="class in edu.stanford.nlp.parser.lexparser">Options</A> <B>op</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smoothInUnknownsThreshold</H3>
<PRE>
int <B>smoothInUnknownsThreshold</B></PRE>
<DL>
<DD>If a word has been seen more than this many times, then relative
 frequencies of tags are used for POS assignment; if not, they are smoothed
 with tag priors.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smartMutation</H3>
<PRE>
boolean <B>smartMutation</B></PRE>
<DL>
<DD>Have tags changeable based on statistics on word types having various
 taggings.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
wordIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>wordIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>tagIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
seenCounter</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="class in edu.stanford.nlp.stats">ClassicCounter</A>&lt;<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="type parameter in ClassicCounter">E</A>&gt; <B>seenCounter</B></PRE>
<DL>
<DD>Records the number of times word/tag pair was seen in training data.
  Includes word/tag pairs where one is a wildcard not a real word/tag.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth</H3>
<PRE>
double[] <B>smooth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
flexiTag</H3>
<PRE>
boolean <B>flexiTag</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSignatureForKnownSmoothing</H3>
<PRE>
boolean <B>useSignatureForKnownSmoothing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
baseTagCounts</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>baseTagCounts</B></PRE>
<DL>
<DD>Only used when training, specifically when training on sentenes
 that weren't part of annotated (eg markovized, etc) data
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagsToBaseTags</H3>
<PRE>
int[] <B>tagsToBaseTags</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.ChineseCharacterBasedLexicon"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/ChineseCharacterBasedLexicon.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.ChineseCharacterBasedLexicon</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5357655683145854069L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
lengthPenalty</H3>
<PRE>
double <B>lengthPenalty</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
penaltyType</H3>
<PRE>
int <B>penaltyType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
charDistributions</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>charDistributions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
knownChars</H3>
<PRE>
java.util.Set&lt;E&gt; <B>knownChars</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
POSDistribution</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/Distribution.html" title="class in edu.stanford.nlp.stats">Distribution</A>&lt;<A HREF="edu/stanford/nlp/stats/Distribution.html" title="type parameter in Distribution">E</A>&gt; <B>POSDistribution</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnknownCharacterModel</H3>
<PRE>
boolean <B>useUnknownCharacterModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>wordIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>tagIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.ChineseLexicon"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/ChineseLexicon.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.ChineseLexicon</A> extends <A HREF="edu/stanford/nlp/parser/lexparser/BaseLexicon.html" title="class in edu.stanford.nlp.parser.lexparser">BaseLexicon</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7836464391021114960L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
useCharBasedUnknownWordModel</H3>
<PRE>
boolean <B>useCharBasedUnknownWordModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGoodTuringUnknownWordModel</H3>
<PRE>
boolean <B>useGoodTuringUnknownWordModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
probRandomWalk</H3>
<PRE>
edu.stanford.nlp.parser.lexparser.RandomWalk <B>probRandomWalk</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/ChineseLexiconAndWordSegmenter.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-6554995189795187918L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
chineseLexicon</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/ChineseLexicon.html" title="class in edu.stanford.nlp.parser.lexparser">ChineseLexicon</A> <B>chineseLexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordSegmenter</H3>
<PRE>
<A HREF="edu/stanford/nlp/process/WordSegmenter.html" title="interface in edu.stanford.nlp.process">WordSegmenter</A> <B>wordSegmenter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
op</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Options.html" title="class in edu.stanford.nlp.parser.lexparser">Options</A> <B>op</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.ChineseSimWordAvgDepGrammar"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/ChineseSimWordAvgDepGrammar.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.ChineseSimWordAvgDepGrammar</A> extends <A HREF="edu/stanford/nlp/parser/lexparser/MLEDependencyGrammar.html" title="class in edu.stanford.nlp.parser.lexparser">MLEDependencyGrammar</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1845503582705055342L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
simSmooth</H3>
<PRE>
double <B>simSmooth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
simArgMap</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>simArgMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
simHeadMap</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>simHeadMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
debug</H3>
<PRE>
boolean <B>debug</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
verbose</H3>
<PRE>
boolean <B>verbose</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
statsCounter</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="class in edu.stanford.nlp.stats">ClassicCounter</A>&lt;<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="type parameter in ClassicCounter">E</A>&gt; <B>statsCounter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/ChineseTreebankParserParams.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams</A> extends <A HREF="edu/stanford/nlp/parser/lexparser/AbstractTreebankParserParams.html" title="class in edu.stanford.nlp.parser.lexparser">AbstractTreebankParserParams</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
ctlp</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees.international.pennchinese">ChineseTreebankLanguagePack</A> <B>ctlp</B></PRE>
<DL>
<DD>The variable ctlp stores the same thing as the tlp variable in
 AbstractTreebankParserParams, but pre-cast to be a
 ChineseTreebankLanguagePack.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
charTags</H3>
<PRE>
boolean <B>charTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCharacterBasedLexicon</H3>
<PRE>
boolean <B>useCharacterBasedLexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMaxentLexicon</H3>
<PRE>
boolean <B>useMaxentLexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMaxentDepGrammar</H3>
<PRE>
boolean <B>useMaxentDepGrammar</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
segment</H3>
<PRE>
boolean <B>segment</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
segmentMarkov</H3>
<PRE>
boolean <B>segmentMarkov</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sunJurafskyHeadFinder</H3>
<PRE>
boolean <B>sunJurafskyHeadFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bikelHeadFinder</H3>
<PRE>
boolean <B>bikelHeadFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
discardFrags</H3>
<PRE>
boolean <B>discardFrags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSimilarWordMap</H3>
<PRE>
boolean <B>useSimilarWordMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
segmenterClass</H3>
<PRE>
java.lang.String <B>segmenterClass</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lex</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Lexicon.html" title="interface in edu.stanford.nlp.parser.lexparser">Lexicon</A> <B>lex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
segmenter</H3>
<PRE>
<A HREF="edu/stanford/nlp/process/WordSegmenter.html" title="interface in edu.stanford.nlp.process">WordSegmenter</A> <B>segmenter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
headFinder</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A> <B>headFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseSplitDouHao</H3>
<PRE>
boolean <B>chineseSplitDouHao</B></PRE>
<DL>
<DD>Chinese: Split the dou hao (a punctuation mark separating
 members of a list) from other punctuation.  Good but included below.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseSplitPunct</H3>
<PRE>
boolean <B>chineseSplitPunct</B></PRE>
<DL>
<DD>Chinese: split Chinese punctuation several ways, along the lines
 of English punctuation plus another category for the dou hao.  Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseSplitPunctLR</H3>
<PRE>
boolean <B>chineseSplitPunctLR</B></PRE>
<DL>
<DD>Chinese: split left right/paren quote (if chineseSplitPunct is also
 true.  Only very marginal gains, but seems positive.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markVVsisterIP</H3>
<PRE>
boolean <B>markVVsisterIP</B></PRE>
<DL>
<DD>Chinese: mark VVs that are sister of IP (communication &
 small-clause-taking verbs).  Good: give 0.5%
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markPsisterIP</H3>
<PRE>
boolean <B>markPsisterIP</B></PRE>
<DL>
<DD>Chinese: mark P's that are sister of IP.  Negative effect
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markIPsisterVVorP</H3>
<PRE>
boolean <B>markIPsisterVVorP</B></PRE>
<DL>
<DD>Chinese: mark IP's that are sister of VV or P.  These rarely
 have punctuation. Small positive effect.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markADgrandchildOfIP</H3>
<PRE>
boolean <B>markADgrandchildOfIP</B></PRE>
<DL>
<DD>Chinese: mark ADs that are grandchild of IP.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
gpaAD</H3>
<PRE>
boolean <B>gpaAD</B></PRE>
<DL>
<DD>Grandparent annotate all AD.  Seems slightly negative.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseVerySelectiveTagPA</H3>
<PRE>
boolean <B>chineseVerySelectiveTagPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseSelectiveTagPA</H3>
<PRE>
boolean <B>chineseSelectiveTagPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
markIPsisterBA</H3>
<PRE>
boolean <B>markIPsisterBA</B></PRE>
<DL>
<DD>Chinese: mark IPs that are sister of BA.  These always have
 overt NP.  Very slightly positive.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markVPadjunct</H3>
<PRE>
boolean <B>markVPadjunct</B></PRE>
<DL>
<DD>Chinese: mark phrases that are adjuncts of VP (these tend to be
 locatives/temporals, and have a specific distribution).
 Necessary even with chineseSplitVP==3 and parent annotation because
 parent annotation happens with unsplit parent categories.
 Slightly positive.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markNPmodNP</H3>
<PRE>
boolean <B>markNPmodNP</B></PRE>
<DL>
<DD>Chinese: mark NP modifiers of NPs. Quite positive (0.5%)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markModifiedNP</H3>
<PRE>
boolean <B>markModifiedNP</B></PRE>
<DL>
<DD>Chinese: mark left-modified NPs (rightmost NPs with a left-side
 mod).  Slightly positive.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markNPconj</H3>
<PRE>
boolean <B>markNPconj</B></PRE>
<DL>
<DD>Chinese: mark NPs that are conjuncts.  Negative on small set.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markMultiNtag</H3>
<PRE>
boolean <B>markMultiNtag</B></PRE>
<DL>
<DD>Chinese: mark nominal tags that are part of multi-nominal
 rewrites.  Doesn't seem any good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markIPsisDEC</H3>
<PRE>
boolean <B>markIPsisDEC</B></PRE>
<DL>
<DD>Chinese: mark IPs that are part of prenominal modifiers. Negative.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markIPconj</H3>
<PRE>
boolean <B>markIPconj</B></PRE>
<DL>
<DD>Chinese: mark IPs that are conjuncts.  Or those that have
 (adjuncts or subjects)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markIPadjsubj</H3>
<PRE>
boolean <B>markIPadjsubj</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseSplitVP</H3>
<PRE>
int <B>chineseSplitVP</B></PRE>
<DL>
<DD>Chinese VP splitting.  0 = none;
 1 = mark with -BA a VP that directly dominates a BA;
 2 = mark with -BA a VP that directly dominates a BA or a VP that
     directly dominates a BA
 3 = split VPs into VP-COMP, VP-CRD, VP-ADJ.  (Negative value.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
mergeNNVV</H3>
<PRE>
boolean <B>mergeNNVV</B></PRE>
<DL>
<DD>Chinese: merge NN and VV.  A lark.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryIP</H3>
<PRE>
boolean <B>unaryIP</B></PRE>
<DL>
<DD>Chinese: unary category marking
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryCP</H3>
<PRE>
boolean <B>unaryCP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
paRootDtr</H3>
<PRE>
boolean <B>paRootDtr</B></PRE>
<DL>
<DD>Chinese: parent annotate daughter of root.  Meant only for
 selectivesplit=false.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markPostverbalP</H3>
<PRE>
boolean <B>markPostverbalP</B></PRE>
<DL>
<DD>Chinese: mark P with a left aunt VV, and PP with a left sister
 VV.  Note that it's necessary to mark both to thread the
 context-marking.  Used to identify post-verbal P's, which are
 rare.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markPostverbalPP</H3>
<PRE>
boolean <B>markPostverbalPP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitBaseNP</H3>
<PRE>
boolean <B>splitBaseNP</B></PRE>
<DL>
<DD>Mark base NPs.  Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagWordSize</H3>
<PRE>
boolean <B>tagWordSize</B></PRE>
<DL>
<DD>Annotate tags for number of characters contained.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markCC</H3>
<PRE>
boolean <B>markCC</B></PRE>
<DL>
<DD>Mark phrases which are conjunctions.
 Appears negative, even with 200K words training data.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPTMP</H3>
<PRE>
boolean <B>splitNPTMP</B></PRE>
<DL>
<DD>Whether to retain the -TMP functional tag on various phrasal
 categories.  On 80K words training, minutely helpful; on 200K
 words, best option gives 0.6%.  Doing
 splitNPTMP and splitPPTMP (but not splitXPTMP) is best.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPPTMP</H3>
<PRE>
boolean <B>splitPPTMP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitXPTMP</H3>
<PRE>
boolean <B>splitXPTMP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dominatesV</H3>
<PRE>
boolean <B>dominatesV</B></PRE>
<DL>
<DD>Verbal distance -- mark whether symbol dominates a verb (V*).
 Seems bad for Chinese.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useGoodTuringUnknownWordModel</H3>
<PRE>
boolean <B>useGoodTuringUnknownWordModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCharBasedUnknownWordModel</H3>
<PRE>
boolean <B>useCharBasedUnknownWordModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lengthPenalty</H3>
<PRE>
double <B>lengthPenalty</B></PRE>
<DL>
<DD>Parameters for a ChineseCharacterBasedLexicon
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnknownCharacterModel</H3>
<PRE>
boolean <B>useUnknownCharacterModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
penaltyType</H3>
<PRE>
int <B>penaltyType</B></PRE>
<DL>
<DD>penaltyType should be set as follows:
 0: no length penalty
 1: quadratic length penalty
 2: penalty for continuation chars only
 TODO: make this an enum
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
depGramFeatureLevel</H3>
<PRE>
int <B>depGramFeatureLevel</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/EnglishTreebankParserParams.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams</A> extends <A HREF="edu/stanford/nlp/parser/lexparser/AbstractTreebankParserParams.html" title="class in edu.stanford.nlp.parser.lexparser">AbstractTreebankParserParams</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4153878351331522581L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
headFinder</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A> <B>headFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
englishTrain</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/EnglishTreebankParserParams.EnglishTrain.html" title="class in edu.stanford.nlp.parser.lexparser">EnglishTreebankParserParams.EnglishTrain</A> <B>englishTrain</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
englishTest</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/EnglishTreebankParserParams.EnglishTest.html" title="class in edu.stanford.nlp.parser.lexparser">EnglishTreebankParserParams.EnglishTest</A> <B>englishTest</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams.EnglishTest"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/EnglishTreebankParserParams.EnglishTest.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams.EnglishTest</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>183157656745674521L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
retainNPTMPSubcategories</H3>
<PRE>
boolean <B>retainNPTMPSubcategories</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
retainTMPSubcategories</H3>
<PRE>
boolean <B>retainTMPSubcategories</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
retainADVSubcategories</H3>
<PRE>
boolean <B>retainADVSubcategories</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
makeCopulaHead</H3>
<PRE>
boolean <B>makeCopulaHead</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams.EnglishTrain"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/EnglishTreebankParserParams.EnglishTrain.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams.EnglishTrain</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1831576434872643L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
leaveItAll</H3>
<PRE>
int <B>leaveItAll</B></PRE>
<DL>
<DD>if true, leave all PTB (functional tag) annotations (bad)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitIN</H3>
<PRE>
int <B>splitIN</B></PRE>
<DL>
<DD>Annotate prepositions into subcategories.  Values:
 0 = no annotation
 1 = IN with a ^S.* parent (putative subordinating
 conjunctions) marked differently from others (real prepositions). OK.
 2 = Annotate IN prepositions 3 ways: ^S.* parent, ^N.* parent or rest
 (generally predicative ADJP, VP). Better than sIN=1.  Good.
 3 = Annotate prepositions 6 ways: real feature engineering. Great.
 4 = Refinement of 3: allows -SC under SINV, WHADVP for -T and no -SCC
     if the parent is an NP.
 5 = Like 4 but maps TO to IN in a "nominal" (N*, P*, A*) context.
 6 = 4, but mark V/A complement and leave noun ones unmarked instead.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitQuotes</H3>
<PRE>
boolean <B>splitQuotes</B></PRE>
<DL>
<DD>Mark quote marks for single vs. double so don't get mismatched ones.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitSFP</H3>
<PRE>
boolean <B>splitSFP</B></PRE>
<DL>
<DD>Separate out sentence final punct. (. ! ?).  Doesn't help.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPercent</H3>
<PRE>
boolean <B>splitPercent</B></PRE>
<DL>
<DD>Mark the nouns that are percent signs.  Slightly good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPpercent</H3>
<PRE>
int <B>splitNPpercent</B></PRE>
<DL>
<DD>Mark phrases that are headed by %.
 A value of 0 = do nothing, 1 = only NP, 2 = NP and ADJP,
 3 = NP, ADJP and QP, 4 = any phrase.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagRBGPA</H3>
<PRE>
boolean <B>tagRBGPA</B></PRE>
<DL>
<DD>Grand parent annotate RB to try to distinguish sentential ones and
  ones in places like NP post modifier (things like 'very' are already
  distinguished as their parent is ADJP).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNNP</H3>
<PRE>
int <B>splitNNP</B></PRE>
<DL>
<DD>Mark NNP words as to position in phrase (single, left, right, inside)
  or subcategorizes NNP(S) as initials or initial/final in NP.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
joinPound</H3>
<PRE>
boolean <B>joinPound</B></PRE>
<DL>
<DD>Join pound with dollar.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
joinJJ</H3>
<PRE>
boolean <B>joinJJ</B></PRE>
<DL>
<DD>Joint comparative and superlative adjective with positive.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
joinNounTags</H3>
<PRE>
boolean <B>joinNounTags</B></PRE>
<DL>
<DD>Join proper nouns with common nouns. This isn't to improve
 performance, but because Genia doesn't use proper noun tags in
 general.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPPJJ</H3>
<PRE>
boolean <B>splitPPJJ</B></PRE>
<DL>
<DD>A special test for "such" mainly ("such as Fred"). A wash, so omit
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitTRJJ</H3>
<PRE>
boolean <B>splitTRJJ</B></PRE>
<DL>
<DD>Put a special tag on 'transitive adjectives' with NP complement, like
 'due May 15' -- it also catches 'such' in 'such as NP', which may
 be a good.  Matches 658 times in 2-21 training corpus. Wash.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitJJCOMP</H3>
<PRE>
boolean <B>splitJJCOMP</B></PRE>
<DL>
<DD>Put a special tag on 'adjectives with complements'.  This acts as a
 general subcat feature for adjectives.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitMoreLess</H3>
<PRE>
boolean <B>splitMoreLess</B></PRE>
<DL>
<DD>Specially mark the comparative/superlative words: less, least,
 more, most
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryDT</H3>
<PRE>
boolean <B>unaryDT</B></PRE>
<DL>
<DD>Mark "Intransitive" DT.  Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryRB</H3>
<PRE>
boolean <B>unaryRB</B></PRE>
<DL>
<DD>Mark "Intransitive" RB.  Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryPRP</H3>
<PRE>
boolean <B>unaryPRP</B></PRE>
<DL>
<DD>"Intransitive" PRP. Wash -- basically a no-op really.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markReflexivePRP</H3>
<PRE>
boolean <B>markReflexivePRP</B></PRE>
<DL>
<DD>Mark reflexive PRP words.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unaryIN</H3>
<PRE>
boolean <B>unaryIN</B></PRE>
<DL>
<DD>Mark "Intransitive" IN. Minutely negative.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitCC</H3>
<PRE>
int <B>splitCC</B></PRE>
<DL>
<DD>Provide annotation of conjunctions.  Gives modest gains (numbers
  shown F1 increase with respect to goodPCFG in June 2005).  A value of
  1 annotates both "and" and "or" as "CC-C" (+0.29%),
  2 annotates "but" and "&amp;" separately (+0.17%),
  3 annotates just "and" (equalsIgnoreCase) (+0.11%),
  0 annotates nothing (+0.00%).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNOT</H3>
<PRE>
boolean <B>splitNOT</B></PRE>
<DL>
<DD>Annotates forms of "not" specially as tag "NOT". BAD
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitRB</H3>
<PRE>
boolean <B>splitRB</B></PRE>
<DL>
<DD>Split modifier (NP, AdjP) adverbs from others.
 This does nothing if you're already doing tagPA.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitAux</H3>
<PRE>
int <B>splitAux</B></PRE>
<DL>
<DD>Make special tags for forms of BE and HAVE (and maybe DO/HELP, etc.).
 A value of 0 is do nothing.
 A value of 1 is the basic form.  Positive PCFG effect,
   but neutral to negative in Factored, and impossible if you use gPA.
 A value of 2 adds in "s" = "'s"
 and delves further to disambiguate "'s" as BE or HAVE.  Theoretically
 good, but no practical gains.
 A value of 3 adds DO.
 A value of 4 adds HELP (which also takes VB form complement) as DO.
 A value of 5 adds LET (which also takes VB form complement) as DO.
 A value of 6 adds MAKE (which also takes VB form complement) as DO.
 A value of 7 adds WATCH, SEE (which also take VB form complement) as DO.
 A value of 8 adds come, go, but not inflections (which colloquially
   can take a VB form complement) as DO.
 A value of 9 adds GET as BE.
 Differences are small. You get about 0.3 F1 by doing something; the best
 appear to be 2 or 3 for sentence exact and 7 or 8 for LP/LR F1.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
vpSubCat</H3>
<PRE>
boolean <B>vpSubCat</B></PRE>
<DL>
<DD>Pitiful attempt at marking V* preterms with their surface subcat
 frames.  Bad so far.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markDitransV</H3>
<PRE>
int <B>markDitransV</B></PRE>
<DL>
<DD>Attempt to record ditransitive verbs.  The value 0 means do nothing;
 1 records two or more NP or S* arguments, and 2 means to only record
 two or more NP arguments (that aren't NP-TMP).
 1 gave neutral to bad results.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitVP</H3>
<PRE>
int <B>splitVP</B></PRE>
<DL>
<DD>Add (head) tags to VPs.  An argument of
 0 = no head-subcategorization of VPs,
 1 = add head tags (anything, as given by HeadFinder),
 2 = add head tags, but collapse finite verb tags (VBP, VBD, VBZ, MD)
     together,
 3 = only annotate verbal tags, and collapse finite verb tags
     (annotation is VBF, TO, VBG, VBN, VB, or zero),
 4 = only split on categories of VBF, TO, VBG, VBN, VB, and map
     cases that are not headed by a verbal category to an appropriate
     category based on word suffix (ing, d, t, s, to) or to VB otherwise.
 We usually use a value of 3; 2 or 3 is much better than 0.
 See also <code>splitVPNPAgr</code>. If it is true, its effects override
 any value set for this parameter.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitVPNPAgr</H3>
<PRE>
boolean <B>splitVPNPAgr</B></PRE>
<DL>
<DD>Put enough marking on VP and NP to permit "agreement".
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitSTag</H3>
<PRE>
int <B>splitSTag</B></PRE>
<DL>
<DD>Mark S/SINV/SQ nodes according to verbal tag.  Meanings are:
 0 = no subcategorization.
 1 = mark with head tag
 2 = mark only -VBF if VBZ/VBD/VBP/MD tag
 3 = as 2 and mark -VBNF if TO/VBG/VBN/VB
 4 = as 2 but only mark S not SINV/SQ
 5 = as 3 but only mark S not SINV/SQ
 Previously seen as bad.  Option 4 might be promising now.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markContainedVP</H3>
<PRE>
boolean <B>markContainedVP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPPRP</H3>
<PRE>
boolean <B>splitNPPRP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dominatesV</H3>
<PRE>
int <B>dominatesV</B></PRE>
<DL>
<DD>Verbal distance -- mark whether symbol dominates a verb (V*, MD).
 Very good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dominatesI</H3>
<PRE>
boolean <B>dominatesI</B></PRE>
<DL>
<DD>Verbal distance -- mark whether symbol dominates a preposition (IN)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dominatesC</H3>
<PRE>
boolean <B>dominatesC</B></PRE>
<DL>
<DD>Verbal distance -- mark whether symbol dominates a conjunction (CC)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markCC</H3>
<PRE>
int <B>markCC</B></PRE>
<DL>
<DD>Mark phrases which are conjunctions.
 0 = No marking
 1 = Any phrase with a CC daughter that isn't first or last.  Possibly marginally positive.
 2 = As 0 but also a non-marginal CONJP daughter.  In principle good, but no gains.
 3 = More like Charniak.  Not yet implemented.  Need to annotate _before_ annotate children!
     np or vp with two or more np/vp children, a comma, cc or conjp, and nothing else.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitSGapped</H3>
<PRE>
int <B>splitSGapped</B></PRE>
<DL>
<DD>Mark specially S nodes with "gapped" subject (control, raising).
 1 is basic version.  2 is better mark S nodes with "gapped" subject.
 3 seems best on small training set, but all of these are too similar;
 4 can't be differentiated.
 5 is done on tree before empty splitting. (Bad!?)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNumNP</H3>
<PRE>
boolean <B>splitNumNP</B></PRE>
<DL>
<DD>Mark "numeric NPs".  Probably bad?
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPoss</H3>
<PRE>
int <B>splitPoss</B></PRE>
<DL>
<DD>Give a special tag to NPs which are possessive NPs (end in 's).
 A value of 0 means do nothing, 1 means tagging possessive NPs with
 "-P", 2 means restructure possessive NPs so that they introduce a
 POSSP node that
 takes as children the POS and a regularly structured NP.
 I.e., recover standard good linguistic practice circa 1985.
 This seems a good idea, but is almost a no-op (modulo fine points of
 markovization), since the previous NP-P phrase already uniquely
 captured what is now a POSSP.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitBaseNP</H3>
<PRE>
int <B>splitBaseNP</B></PRE>
<DL>
<DD>Mark base NPs.  A value of 0 = no marking, 1 = marking
 baseNP (ones which rewrite just as preterminals), and 2 = doing
 Collins-style marking, where an extra NP node is inserted above a
 baseNP, if it isn't
 already in an NP over NP construction, as in Collins 1999.
 <i>This option shouldn't really be in EnglishTrain since it's needed
 at parsing time.  But we don't currently use it....</i>
 A value of 1 is good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitTMP</H3>
<PRE>
int <B>splitTMP</B></PRE>
<DL>
<DD>Retain NP-TMP (or maybe PP-TMP) annotation.  Good.
 The values for this parameter are defined in
 NPTmpRetainingTreeNormalizer.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitSbar</H3>
<PRE>
int <B>splitSbar</B></PRE>
<DL>
<DD>Split SBAR nodes.
  1 = mark 'in order to' purpose clauses; this is actually a small and
  inconsistent part of what is marked SBAR-PRP in the treebank, which
  is mainly 'because' reason clauses.
  2 = mark all infinitive SBAR.
  3 = do 1 and 2.
  A value of 1 seems minutely positive; 2 and 3 seem negative.
  Also get 'in case Sfin', 'In order to', and on one occasion
  'in order that'
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPADV</H3>
<PRE>
int <B>splitNPADV</B></PRE>
<DL>
<DD>Retain NP-ADV annotation.  0 means strip "-ADV" annotation.  1 means to
 retain it, and to percolate it down to a head tag providing it can
 do it through a path of only NP nodes.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPNNP</H3>
<PRE>
int <B>splitNPNNP</B></PRE>
<DL>
<DD>Mark NP-NNP.  0 is nothing; 1 is only NNP head, 2 is NNP and NNPS
 head; 3 is NNP or NNPS anywhere in local NP.  All bad!
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
correctTags</H3>
<PRE>
boolean <B>correctTags</B></PRE>
<DL>
<DD>'Correct' tags to produce verbs in VPs, etc. where possible
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
rightPhrasal</H3>
<PRE>
boolean <B>rightPhrasal</B></PRE>
<DL>
<DD>Right edge has a phrasal node.  Bad?
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
sisterSplitLevel</H3>
<PRE>
int <B>sisterSplitLevel</B></PRE>
<DL>
<DD>Set the support * KL cutoff level (1-4) for sister splitting
 -- don't use it, as far as we can tell so far
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
gpaRootVP</H3>
<PRE>
boolean <B>gpaRootVP</B></PRE>
<DL>
<DD>Grand-parent annotate (root mark) VP below ROOT.  Seems negative.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
makePPTOintoIN</H3>
<PRE>
int <B>makePPTOintoIN</B></PRE>
<DL>
<DD>Change TO inside PP to IN.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
collapseWhCategories</H3>
<PRE>
int <B>collapseWhCategories</B></PRE>
<DL>
<DD>Collapse WHPP with PP, etc., in training and perhaps in evaluation.
  1 = collapse phrasal categories.
  2 = collapse POS categories.
  4 = restore them in output (not yet implemented)
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.IntDependency"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/IntDependency.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.IntDependency</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
head</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/IntTaggedWord.html" title="class in edu.stanford.nlp.parser.lexparser">IntTaggedWord</A> <B>head</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
arg</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/IntTaggedWord.html" title="class in edu.stanford.nlp.parser.lexparser">IntTaggedWord</A> <B>arg</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
leftHeaded</H3>
<PRE>
boolean <B>leftHeaded</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
distance</H3>
<PRE>
short <B>distance</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.IntTaggedWord"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/IntTaggedWord.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.IntTaggedWord</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
word</H3>
<PRE>
int <B>word</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tag</H3>
<PRE>
short <B>tag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.MLEDependencyGrammar"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/MLEDependencyGrammar.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.MLEDependencyGrammar</A> extends <A HREF="edu/stanford/nlp/parser/lexparser/AbstractDependencyGrammar.html" title="class in edu.stanford.nlp.parser.lexparser">AbstractDependencyGrammar</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;stream)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<HR>
<A NAME="writeObject(java.io.ObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
private void <B>writeObject</B>(java.io.ObjectOutputStream&nbsp;stream)
                  throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
useSmoothTagProjection</H3>
<PRE>
boolean <B>useSmoothTagProjection</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnigramWordSmoothing</H3>
<PRE>
boolean <B>useUnigramWordSmoothing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numWordTokens</H3>
<PRE>
int <B>numWordTokens</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
argCounter</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="class in edu.stanford.nlp.stats">ClassicCounter</A>&lt;<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="type parameter in ClassicCounter">E</A>&gt; <B>argCounter</B></PRE>
<DL>
<DD>Stores all the counts for dependencies (with and without the word
  being a wildcard) in the reduced tag space.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
stopCounter</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="class in edu.stanford.nlp.stats">ClassicCounter</A>&lt;<A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="type parameter in ClassicCounter">E</A>&gt; <B>stopCounter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aT_hTWd</H3>
<PRE>
double <B>smooth_aT_hTWd</B></PRE>
<DL>
<DD>Bayesian m-estimate prior for aT given hTWd against base distribution
  of aT given hTd.
  TODO: Note that these values are overwritten in the constructor. Find what is best and then maybe remove these defaults!
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aTW_hTWd</H3>
<PRE>
double <B>smooth_aTW_hTWd</B></PRE>
<DL>
<DD>Bayesian m-estimate prior for aTW given hTWd against base distribution
  of aTW given hTd.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_stop</H3>
<PRE>
double <B>smooth_stop</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
interp</H3>
<PRE>
double <B>interp</B></PRE>
<DL>
<DD>Interpolation between model that directly predicts aTW and model
  that predicts aT and then aW given aT.  This percent of the mass
  is on the model directly predicting aTW.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aTW_aT</H3>
<PRE>
double <B>smooth_aTW_aT</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aTW_hTd</H3>
<PRE>
double <B>smooth_aTW_hTd</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aT_hTd</H3>
<PRE>
double <B>smooth_aT_hTd</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smooth_aPTW_aPT</H3>
<PRE>
double <B>smooth_aPTW_aPT</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smoothTP</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TagProjection.html" title="interface in edu.stanford.nlp.parser.lexparser">TagProjection</A> <B>smoothTP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smoothTPIndex</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Index.html" title="interface in edu.stanford.nlp.util">Index</A>&lt;<A HREF="edu/stanford/nlp/util/Index.html" title="type parameter in Index">E</A>&gt; <B>smoothTPIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.Options"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/Options.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.Options</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;in)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD>Making the TestOptions transient means it won't even be
 constructed when you deserialize an Options, so we need to
 construct it on our own when deserializing
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
lexOptions</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/Options.LexOptions.html" title="class in edu.stanford.nlp.parser.lexparser">Options.LexOptions</A> <B>lexOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tlpParams</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TreebankLangParserParams.html" title="interface in edu.stanford.nlp.parser.lexparser">TreebankLangParserParams</A> <B>tlpParams</B></PRE>
<DL>
<DD>The treebank-specific parser parameters  to use.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
forceCNF</H3>
<PRE>
boolean <B>forceCNF</B></PRE>
<DL>
<DD>Forces parsing with strictly CNF grammar -- unary chains are converted
 to XP&amp;YP symbols and back
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
doPCFG</H3>
<PRE>
boolean <B>doPCFG</B></PRE>
<DL>
<DD>Do a PCFG parse of the sentence.  If both variables are on,
 also do a combined parse of the sentence.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
doDep</H3>
<PRE>
boolean <B>doDep</B></PRE>
<DL>
<DD>Do a dependency parse of the sentence.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
freeDependencies</H3>
<PRE>
boolean <B>freeDependencies</B></PRE>
<DL>
<DD>if true, any child can be the head (seems rather bad!)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
directional</H3>
<PRE>
boolean <B>directional</B></PRE>
<DL>
<DD>Whether dependency grammar considers left/right direction. Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
genStop</H3>
<PRE>
boolean <B>genStop</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSmoothTagProjection</H3>
<PRE>
boolean <B>useSmoothTagProjection</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnigramWordSmoothing</H3>
<PRE>
boolean <B>useUnigramWordSmoothing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
distance</H3>
<PRE>
boolean <B>distance</B></PRE>
<DL>
<DD>Use distance bins in the dependency calculations
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
coarseDistance</H3>
<PRE>
boolean <B>coarseDistance</B></PRE>
<DL>
<DD>Use coarser distance (4 bins) in dependency calculations
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dcTags</H3>
<PRE>
boolean <B>dcTags</B></PRE>
<DL>
<DD>"double count" tags rewrites as word in PCFG and Dep parser.  Good for
 combined parsing only (it used to not kick in for PCFG parsing).  This
 option is only used at Test time, but it is now in Options, so the
 correct choice for a grammar is recorded by a serialized parser.
 You should turn this off for a vanilla PCFG parser.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
nodePrune</H3>
<PRE>
boolean <B>nodePrune</B></PRE>
<DL>
<DD>If true, inside the factored parser, remove any node from the final
 chosen tree which improves the PCFG score. This was added as the
 dependency factor tends to encourage 'deep' trees.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
trainOptions</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TrainOptions.html" title="class in edu.stanford.nlp.parser.lexparser">TrainOptions</A> <B>trainOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordFunction</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Function.html" title="interface in edu.stanford.nlp.util">Function</A>&lt;<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T1</A>,<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T2</A>&gt; <B>wordFunction</B></PRE>
<DL>
<DD>A function that maps words used in training and testing to new
 words.  For example, it could be a function to lowercase text,
 such as edu.stanford.nlp.util.LowercaseFunction (which makes the
 parser case insensitive).  This function is applied in
 LexicalizedParserQuery.parse and in the training methods which
 build a new parser.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
rerankerKBest</H3>
<PRE>
int <B>rerankerKBest</B></PRE>
<DL>
<DD>If the parser has a reranker, it looks at this many trees when
 building the reranked list.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
baseParserWeight</H3>
<PRE>
double <B>baseParserWeight</B></PRE>
<DL>
<DD>If reranking sentences, we can use the score from the original
 parser as well.  This tells us how much weight to give that score.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.Options.LexOptions"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/Options.LexOptions.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.Options.LexOptions</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2805351374506855632L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
useUnknownWordSignatures</H3>
<PRE>
int <B>useUnknownWordSignatures</B></PRE>
<DL>
<DD>Whether to use suffix and capitalization information for unknowns.
 Within the BaseLexicon model options have the following meaning:
 0 means a single unknown token.  1 uses suffix, and capitalization.
 2 uses a variant (richer) form of signature.  Good.
 Use this one.  Using the richer signatures in versions 3 or 4 seems
 to have very marginal or no positive value.
 3 uses a richer form of signature that mimics the NER word type
 patterns.  4 is a variant of 2.  5 is another with more English
 specific morphology (good for English unknowns!).
 6-9 are options for Arabic.  9 codes some patterns for numbers and
 derivational morphology, but also supports unknownPrefixSize and
 unknownSuffixSize.
 For German, 0 means a single unknown token, and non-zero means to use
 capitalization of first letter and a suffix of length
 unknownSuffixSize.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
wordVectorFile</H3>
<PRE>
java.lang.String <B>wordVectorFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numHid</H3>
<PRE>
int <B>numHid</B></PRE>
<DL>
<DD>Number of hidden units in the word vectors.  As setting of 0
 will make it try to extract the size from the data file.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smoothInUnknownsThreshold</H3>
<PRE>
int <B>smoothInUnknownsThreshold</B></PRE>
<DL>
<DD>Words more common than this are tagged with MLE P(t|w). Default 100. The
 smoothing is sufficiently slight that changing this has little effect.
 But set this to 0 to be able to use the parser as a vanilla PCFG with
 no smoothing (not as a practical parser but for exposition or debugging).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
smartMutation</H3>
<PRE>
boolean <B>smartMutation</B></PRE>
<DL>
<DD>Smarter smoothing for rare words.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnicodeType</H3>
<PRE>
boolean <B>useUnicodeType</B></PRE>
<DL>
<DD>Make use of unicode code point types in smoothing.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownSuffixSize</H3>
<PRE>
int <B>unknownSuffixSize</B></PRE>
<DL>
<DD>For certain Lexicons, a certain number of word-final letters are
  used to subclassify the unknown token. This gives the number of
  letters.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownPrefixSize</H3>
<PRE>
int <B>unknownPrefixSize</B></PRE>
<DL>
<DD>For certain Lexicons, a certain number of word-initial letters are
  used to subclassify the unknown token. This gives the number of
  letters.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
uwModelTrainer</H3>
<PRE>
java.lang.String <B>uwModelTrainer</B></PRE>
<DL>
<DD>Model for unknown words that the lexicon should use.  This is the
 name of a class.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
flexiTag</H3>
<PRE>
boolean <B>flexiTag</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSignatureForKnownSmoothing</H3>
<PRE>
boolean <B>useSignatureForKnownSmoothing</B></PRE>
<DL>
<DD>Whether to use signature rather than just being unknown as prior in
  known word smoothing.  Currently only works if turned on for English.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
wordClassesFile</H3>
<PRE>
java.lang.String <B>wordClassesFile</B></PRE>
<DL>
<DD>A file of word class data which may be used for smoothing,
  normally instead of hand-specified signatures.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.TestOptions"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/TestOptions.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.TestOptions</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>7256526346598L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
noRecoveryTagging</H3>
<PRE>
boolean <B>noRecoveryTagging</B></PRE>
<DL>
<DD>If false, then failure of the PCFG parser to parse a sentence
 will trigger allowing all tags for words in parse recovery mode,
 with a log probability of -1000.
 If true, these extra taggings are not added.
 It is false by default. Use option -noRecoveryTagging to set
 to true.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
doRecovery</H3>
<PRE>
boolean <B>doRecovery</B></PRE>
<DL>
<DD>If true, then  failure of the PCFG factor to parse a sentence
  will trigger parse recovery mode.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useN5</H3>
<PRE>
boolean <B>useN5</B></PRE>
<DL>
<DD>If true, the n^4 "speed-up" is not used with the Factored Parser.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useFastFactored</H3>
<PRE>
boolean <B>useFastFactored</B></PRE>
<DL>
<DD>If true, use approximate factored algorithm, which just rescores
  PCFG k best, rather than exact factored algorithm.  This algorithm
  requires the dependency grammar to exist for rescoring, but not for
  the dependency grammar to be run.  Hence the correct usage for
  guarding code only required for exact A* factored parsing is now
  if (op.doPCFG &amp;&amp; op.doDep &amp;&amp; ! Test.useFastFactored).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
iterativeCKY</H3>
<PRE>
boolean <B>iterativeCKY</B></PRE>
<DL>
<DD>If true, use faster iterative deepening CKY algorithm.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
maxLength</H3>
<PRE>
int <B>maxLength</B></PRE>
<DL>
<DD>The maximum sentence length (including punctuation, etc.) to parse.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
MAX_ITEMS</H3>
<PRE>
int <B>MAX_ITEMS</B></PRE>
<DL>
<DD>The maximum number of edges and hooks combined that the factored parser
 will build before giving up.  This number should probably be relative to
 the sentence length parsed. In general, though, if the parser cannot parse
 a sentence after this much work then there is no good parse consistent
 between the PCFG and Dependency parsers.  (Normally, depending on other
 flags), the parser will then just return the best PCFG parse.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unseenSmooth</H3>
<PRE>
double <B>unseenSmooth</B></PRE>
<DL>
<DD>The amount of smoothing put in (as an m-estimate) for unknown words.
  If negative, set by the code in the lexicon class.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
increasingLength</H3>
<PRE>
boolean <B>increasingLength</B></PRE>
<DL>
<DD>Parse trees in test treebank in order of increasing length.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
preTag</H3>
<PRE>
boolean <B>preTag</B></PRE>
<DL>
<DD>Tag the sentences first, then parse given those (coarse) tags.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
forceTags</H3>
<PRE>
boolean <B>forceTags</B></PRE>
<DL>
<DD>Parse using only tags given from correct answer or the POS tagger
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
forceTagBeginnings</H3>
<PRE>
boolean <B>forceTagBeginnings</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
taggerSerializedFile</H3>
<PRE>
java.lang.String <B>taggerSerializedFile</B></PRE>
<DL>
<DD>POS tagger model used when preTag is enabled.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
noFunctionalForcing</H3>
<PRE>
boolean <B>noFunctionalForcing</B></PRE>
<DL>
<DD>Only valid with force tags - strips away functionals when forcing
 the tags, meaning tags have to start
 appropriately but the parser will assign the functional part.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
evalb</H3>
<PRE>
boolean <B>evalb</B></PRE>
<DL>
<DD>Write EvalB-readable output files.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
verbose</H3>
<PRE>
boolean <B>verbose</B></PRE>
<DL>
<DD>Print a lot of extra output as you parse.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
exhaustiveTest</H3>
<PRE>
boolean <B>exhaustiveTest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
pcfgThreshold</H3>
<PRE>
boolean <B>pcfgThreshold</B></PRE>
<DL>
<DD>If this variable is true, and the sum of the inside and outside score
  for a constituent is worse than the best known score for a sentence by
  more than <code>pcfgThresholdValue</code>, then -Inf is returned as the
  outside Score by <code>oScore()</code> (while otherwise the true
  outside score is returned).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
pcfgThresholdValue</H3>
<PRE>
double <B>pcfgThresholdValue</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printAllBestParses</H3>
<PRE>
boolean <B>printAllBestParses</B></PRE>
<DL>
<DD>Print out all best PCFG parses.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
depWeight</H3>
<PRE>
double <B>depWeight</B></PRE>
<DL>
<DD>Weighting on dependency log probs.  The dependency grammar negative log
 probability scores are simply multiplied by this number.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
prunePunc</H3>
<PRE>
boolean <B>prunePunc</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
addMissingFinalPunctuation</H3>
<PRE>
boolean <B>addMissingFinalPunctuation</B></PRE>
<DL>
<DD>If a token list does not have sentence final punctuation near the
  end, then automatically add the default one.
  This might help parsing if the treebank is all punctuated.
  Not done if reading a treebank.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFormat</H3>
<PRE>
java.lang.String <B>outputFormat</B></PRE>
<DL>
<DD>Determines format of output trees: choose among penn, oneline
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFormatOptions</H3>
<PRE>
java.lang.String <B>outputFormatOptions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
writeOutputFiles</H3>
<PRE>
boolean <B>writeOutputFiles</B></PRE>
<DL>
<DD>If true, write files parsed to a new file with the same name except
  for an added ".stp" extension.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFilesDirectory</H3>
<PRE>
java.lang.String <B>outputFilesDirectory</B></PRE>
<DL>
<DD>If the writeOutputFiles option is true, then output files appear in
  this directory.  An unset value (<code>null</code>) means to use
  the directory of the source files.  Use <code>""</code> or <code>.</code>
  for the current directory.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFilesExtension</H3>
<PRE>
java.lang.String <B>outputFilesExtension</B></PRE>
<DL>
<DD>If the writeOutputFiles option is true, then output files appear with
  this extension. Use <code>""</code> for no extension.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFilesPrefix</H3>
<PRE>
java.lang.String <B>outputFilesPrefix</B></PRE>
<DL>
<DD>If the writeOutputFiles option is true, then output files appear with
 this prefix.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
outputkBestEquivocation</H3>
<PRE>
java.lang.String <B>outputkBestEquivocation</B></PRE>
<DL>
<DD>If this option is not null, output the k-best equivocation. Must be specified
 with printPCFGkBest.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
maxSpanForTags</H3>
<PRE>
int <B>maxSpanForTags</B></PRE>
<DL>
<DD>The largest span to consider for word-hood.  Used for parsing unsegmented
 Chinese text and parsing lattices.  Keep it at 1 unless you know what
 you're doing.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
lengthNormalization</H3>
<PRE>
boolean <B>lengthNormalization</B></PRE>
<DL>
<DD>Turns on normalizing scores for sentence length.  Makes no difference
 (except decreased efficiency) unless maxSpanForTags is greater than one.
 Works only for PCFG (so far).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
sample</H3>
<PRE>
boolean <B>sample</B></PRE>
<DL>
<DD>Used when you want to generate sample parses instead of finding the best
 parse.  (NOT YET USED.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
printPCFGkBest</H3>
<PRE>
int <B>printPCFGkBest</B></PRE>
<DL>
<DD>Printing k-best parses from PCFG, when k &gt; 0.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
evalPCFGkBest</H3>
<PRE>
int <B>evalPCFGkBest</B></PRE>
<DL>
<DD>If using a kBest eval, use this many trees.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
printFactoredKGood</H3>
<PRE>
int <B>printFactoredKGood</B></PRE>
<DL>
<DD>Printing k-best parses from PCFG, when k &gt; 0.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
evals</H3>
<PRE>
java.util.Properties <B>evals</B></PRE>
<DL>
<DD>What evaluations to report and how to report them
  (using LexicalizedParser). Known evaluations
  are: pcfgLB, pcfgCB, pcfgDA, pcfgTA, pcfgLL, pcfgRUO, pcfgCUO, pcfgCatE,
  pcfgChildSpecific,
  depDA, depTA, depLL,
  factLB, factCB, factDA, factTA, factLL, factChildSpecific.
  The default is pcfgLB,depDA,factLB,factTA.  You need to negate those
  ones out (e.g., <code>-evals "depDA=false"</code>) if you don't want
  them.
  LB = ParseEval labeled bracketing,   <br>
  CB = crossing brackets and zero crossing bracket rate,   <br>
  DA = dependency accuracy, TA = tagging accuracy,   <br>
  LL = log likelihood score,   <br>
  RUO/CUO = rules/categories under and over proposed,  <br>
  CatE = evaluation by phrasal category.   <br>
  ChildSpecific: supply an argument with =.  F1 will be returned
    for only the nodes which have at least one child that matches
    this regular expression. <br>
  Known styles are: runningAverages, summary, tsv. <br>
  The default style is summary.
  You need to negate it out if you don't want it.
  Invalid names in the argument to this option are not reported!
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
fastFactoredCandidateMultiplier</H3>
<PRE>
int <B>fastFactoredCandidateMultiplier</B></PRE>
<DL>
<DD>This variable says to find k good fast factored parses, how many times
  k of the best PCFG parses should be examined.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
fastFactoredCandidateAddend</H3>
<PRE>
int <B>fastFactoredCandidateAddend</B></PRE>
<DL>
<DD>This variable says to find k good factored parses, how many added on
  best PCFG parses should be examined.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useLexiconToScoreDependencyPwGt</H3>
<PRE>
boolean <B>useLexiconToScoreDependencyPwGt</B></PRE>
<DL>
<DD>If this is true, the Lexicon is used to score P(w|t) in the backoff inside the
  dependency grammar.  (Otherwise, a MLE is used is w is seen, and a constant if
  w is unseen.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useNonProjectiveDependencyParser</H3>
<PRE>
boolean <B>useNonProjectiveDependencyParser</B></PRE>
<DL>
<DD>If this is true, perform non-projective dependency parsing.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
testingThreads</H3>
<PRE>
int <B>testingThreads</B></PRE>
<DL>
<DD>Number of threads to use at test time.  For example,
 -testTreebank can use this to go X times faster, with the
 negative consequence that output is not quite as nicely ordered.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.parser.lexparser.TrainOptions"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/parser/lexparser/TrainOptions.html" title="class in edu.stanford.nlp.parser.lexparser">edu.stanford.nlp.parser.lexparser.TrainOptions</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>72571349843538L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
trainTreeFile</H3>
<PRE>
java.lang.String <B>trainTreeFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainLengthLimit</H3>
<PRE>
int <B>trainLengthLimit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
cheatPCFG</H3>
<PRE>
boolean <B>cheatPCFG</B></PRE>
<DL>
<DD>Add all test set trees to training data for PCFG.
  (Currently only supported in FactoredParser main.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markovFactor</H3>
<PRE>
boolean <B>markovFactor</B></PRE>
<DL>
<DD>Whether to do "horizontal Markovization" (as in ACL 2003 paper).
  False means regular PCFG expansions.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markovOrder</H3>
<PRE>
int <B>markovOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
hSelSplit</H3>
<PRE>
boolean <B>hSelSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
HSEL_CUT</H3>
<PRE>
int <B>HSEL_CUT</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
markFinalStates</H3>
<PRE>
boolean <B>markFinalStates</B></PRE>
<DL>
<DD>Whether or not to mark final states in binarized grammar.
  This must be off to get most value out of grammar compaction.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
openClassTypesThreshold</H3>
<PRE>
int <B>openClassTypesThreshold</B></PRE>
<DL>
<DD>A POS tag has to have been attributed to more than this number of word
 types before it is regarded as an open-class tag.  Unknown words will
 only possibly be tagged as open-class tags (unless flexiTag is on).
 If flexiTag is on, unknown words will be able to be tagged any POS for
 which the unseenMap has nonzero count (that is, the tag was seen for
 a new word after unseen signature counting was started).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
fractionBeforeUnseenCounting</H3>
<PRE>
double <B>fractionBeforeUnseenCounting</B></PRE>
<DL>
<DD>Start to aggregate signature-tag pairs only for words unseen in the first
 this fraction of the data.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
PA</H3>
<PRE>
boolean <B>PA</B></PRE>
<DL>
<DD>This variable controls doing parent annotation of phrasal nodes.  Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
gPA</H3>
<PRE>
boolean <B>gPA</B></PRE>
<DL>
<DD>This variable controls doing 2 levels of parent annotation.  Bad.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
postPA</H3>
<PRE>
boolean <B>postPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
postGPA</H3>
<PRE>
boolean <B>postGPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selectiveSplit</H3>
<PRE>
boolean <B>selectiveSplit</B></PRE>
<DL>
<DD>Only split the "common high KL divergence" parent categories.... Good.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
selectiveSplitCutOff</H3>
<PRE>
double <B>selectiveSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selectivePostSplit</H3>
<PRE>
boolean <B>selectivePostSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selectivePostSplitCutOff</H3>
<PRE>
double <B>selectivePostSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
postSplitWithBaseCategory</H3>
<PRE>
boolean <B>postSplitWithBaseCategory</B></PRE>
<DL>
<DD>Whether, in post-splitting of categories, nodes are annotated with the
  (grand)parent's base category or with its complete subcategorized
  category.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
sisterAnnotate</H3>
<PRE>
boolean <B>sisterAnnotate</B></PRE>
<DL>
<DD>Selective Sister annotation.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
sisterSplitters</H3>
<PRE>
java.util.Set&lt;E&gt; <B>sisterSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
markUnary</H3>
<PRE>
int <B>markUnary</B></PRE>
<DL>
<DD>Mark all unary nodes specially.  Good for just PCFG. Bad for factored.
 markUnary affects phrasal nodes. A value of 0 means to do nothing;
 a value of 1 means to mark the parent (higher) node of a unary rewrite.
 A value of 2 means to mark the child (lower) node of a unary rewrie.
 Values of 1 and 2 only apply if the child (lower) node is phrasal.
 (A value of 1 is better than 2 in combos.)  A value of 1 corresponds
 to the old boolean -unary flag.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
markUnaryTags</H3>
<PRE>
boolean <B>markUnaryTags</B></PRE>
<DL>
<DD>Mark POS tags which are the sole member of their phrasal constituent.
  This is like markUnary=2, applied to POS tags.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPrePreT</H3>
<PRE>
boolean <B>splitPrePreT</B></PRE>
<DL>
<DD>Mark all pre-preterminals (also does splitBaseNP: don't need both)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagPA</H3>
<PRE>
boolean <B>tagPA</B></PRE>
<DL>
<DD>Parent annotation on tags.  Good (for PCFG?)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagSelectiveSplit</H3>
<PRE>
boolean <B>tagSelectiveSplit</B></PRE>
<DL>
<DD>Do parent annotation on tags selectively.  Neutral, but less splits.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tagSelectiveSplitCutOff</H3>
<PRE>
double <B>tagSelectiveSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagSelectivePostSplit</H3>
<PRE>
boolean <B>tagSelectivePostSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagSelectivePostSplitCutOff</H3>
<PRE>
double <B>tagSelectivePostSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
rightRec</H3>
<PRE>
boolean <B>rightRec</B></PRE>
<DL>
<DD>Right edge is right-recursive (X << X) Bad. (NP only is good)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
leftRec</H3>
<PRE>
boolean <B>leftRec</B></PRE>
<DL>
<DD>Left edge is right-recursive (X << X)  Bad.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
collinsPunc</H3>
<PRE>
boolean <B>collinsPunc</B></PRE>
<DL>
<DD>Promote/delete punctuation like Collins.  Bad (!)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitters</H3>
<PRE>
java.util.Set&lt;E&gt; <B>splitters</B></PRE>
<DL>
<DD>Set the splitter strings.  These are a set of parent and/or grandparent
 annotated categories which should be split off.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
postSplitters</H3>
<PRE>
java.util.Set&lt;E&gt; <B>postSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
deleteSplitters</H3>
<PRE>
java.util.Set&lt;E&gt; <B>deleteSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printTreeTransformations</H3>
<PRE>
int <B>printTreeTransformations</B></PRE>
<DL>
<DD>Just for debugging: check that your tree transforms work correctly.  This
 will print the transformations of the first printTreeTransformations trees.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
printAnnotatedPW</H3>
<PRE>
java.io.PrintWriter <B>printAnnotatedPW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printBinarizedPW</H3>
<PRE>
java.io.PrintWriter <B>printBinarizedPW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printStates</H3>
<PRE>
boolean <B>printStates</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
compactGrammar</H3>
<PRE>
int <B>compactGrammar</B></PRE>
<DL>
<DD>How to compact grammars as FSMs.
  0 = no compaction [uses makeSyntheticLabel1],
  1 = no compaction but use label names that wrap from right to left in binarization [uses makeSyntheticLabel2],
  2 = wrapping labels and materialize unary at top rewriting passive to active,
  3 = ExactGrammarCompactor,
  4 = LossyGrammarCompactor,
  5 = CategoryMergingGrammarCompactor.
  (May 2007 CDM note: options 4 and 5 don't seem to be functioning sensibly.  0, 1, and 3
  seem to be the 'good' options. 2 is only useful as input to 3.  There seems to be
  no reason not to use 0, despite the default.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
leftToRight</H3>
<PRE>
boolean <B>leftToRight</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
noTagSplit</H3>
<PRE>
boolean <B>noTagSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
ruleSmoothing</H3>
<PRE>
boolean <B>ruleSmoothing</B></PRE>
<DL>
<DD>Enables linear rule smoothing during grammar extraction
 but before grammar compaction. The alpha term is the same
 as that described in Petrov et al. (2006), and has range [0,1].
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
ruleSmoothingAlpha</H3>
<PRE>
double <B>ruleSmoothingAlpha</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
smoothing</H3>
<PRE>
boolean <B>smoothing</B></PRE>
<DL>
<DD>TODO wsg2011: This is the old grammar smoothing parameter that no
 longer does anything in the parser. It should be removed.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
ruleDiscount</H3>
<PRE>
double <B>ruleDiscount</B></PRE>
<DL>
<DD>Discounts the count of BinaryRule's (only, apparently) in training data.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
printAnnotatedRuleCounts</H3>
<PRE>
boolean <B>printAnnotatedRuleCounts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printAnnotatedStateCounts</H3>
<PRE>
boolean <B>printAnnotatedStateCounts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
basicCategoryTagsInDependencyGrammar</H3>
<PRE>
boolean <B>basicCategoryTagsInDependencyGrammar</B></PRE>
<DL>
<DD>Where to use the basic or split tags in the dependency grammar
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
preTransformer</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A> <B>preTransformer</B></PRE>
<DL>
<DD>A transformer to use on the training data before any other
 processing step.  This is specified by using the -preTransformer
 flag when training the parser.  A comma separated list of classes
 will be turned into a CompositeTransformer.  This can be used to
 strip subcategories, to run a tsurgeon pattern, or any number of
 other useful operations.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
taggedFiles</H3>
<PRE>
java.lang.String <B>taggedFiles</B></PRE>
<DL>
<DD>A set of files to use as extra information in the lexicon.  This
 can provide tagged words which are not part of trees
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
predictSplits</H3>
<PRE>
boolean <B>predictSplits</B></PRE>
<DL>
<DD>Use the method reported by Berkeley for splitting and recombining
 states.  This is an experimental and still in development
 reimplementation of that work.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitCount</H3>
<PRE>
int <B>splitCount</B></PRE>
<DL>
<DD>If we are predicting splits, we loop this many times
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
splitRecombineRate</H3>
<PRE>
double <B>splitRecombineRate</B></PRE>
<DL>
<DD>If we are predicting splits, we recombine states at this rate every loop
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
simpleBinarizedLabels</H3>
<PRE>
boolean <B>simpleBinarizedLabels</B></PRE>
<DL>
<DD>When binarizing trees, don't annotate the labels with anything
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
noRebinarization</H3>
<PRE>
boolean <B>noRebinarization</B></PRE>
<DL>
<DD>When binarizing trees, don't binarize trees with two children.
 Only applies when using inside markov binarization for now.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
trainingThreads</H3>
<PRE>
int <B>trainingThreads</B></PRE>
<DL>
<DD>If the training algorithm allows for parallelization, how many
 threads to use
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dvKBest</H3>
<PRE>
int <B>dvKBest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dvIterations</H3>
<PRE>
int <B>dvIterations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dvBatchSize</H3>
<PRE>
int <B>dvBatchSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
regCost</H3>
<PRE>
double <B>regCost</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
qnIterationsPerBatch</H3>
<PRE>
int <B>qnIterationsPerBatch</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
qnEstimates</H3>
<PRE>
int <B>qnEstimates</B></PRE>
<DL>
<DD>When training the DV parsing method, how many estimates to keep
 for the qn approximation.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
qnTolerance</H3>
<PRE>
double <B>qnTolerance</B></PRE>
<DL>
<DD>When training the DV parsing method, the tolerance to use if we
 want to stop qn early
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
debugOutputSeconds</H3>
<PRE>
int <B>debugOutputSeconds</B></PRE>
<DL>
<DD>If larger than 0, the parser may choose to output debug information every X seconds
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dvSeed</H3>
<PRE>
long <B>dvSeed</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
learningRate</H3>
<PRE>
double <B>learningRate</B></PRE>
<DL>
<DD>How fast to learn (can mean different things for different algorithms)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
deltaMargin</H3>
<PRE>
double <B>deltaMargin</B></PRE>
<DL>
<DD>How much to penalize the wrong trees for how different they are
 from the gold tree when training
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownNumberVector</H3>
<PRE>
boolean <B>unknownNumberVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector specifically for numbers
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownDashedWordVectors</H3>
<PRE>
boolean <B>unknownDashedWordVectors</B></PRE>
<DL>
<DD>Whether or not to handle unknown dashed words by taking the last part
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownCapsVector</H3>
<PRE>
boolean <B>unknownCapsVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector for words with caps in them
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
dvSimplifiedModel</H3>
<PRE>
boolean <B>dvSimplifiedModel</B></PRE>
<DL>
<DD>Make the dv model as simple as possible
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownChineseYearVector</H3>
<PRE>
boolean <B>unknownChineseYearVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese years
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownChineseNumberVector</H3>
<PRE>
boolean <B>unknownChineseNumberVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese numbers
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownChinesePercentVector</H3>
<PRE>
boolean <B>unknownChinesePercentVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese percentages
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
scalingForInit</H3>
<PRE>
double <B>scalingForInit</B></PRE>
<DL>
<DD>How much to scale certain parameters when initializing models.
 For example, the DVParser uses this to rescale its initial
 matrices.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
maxTrainTimeSeconds</H3>
<PRE>
int <B>maxTrainTimeSeconds</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
unkWord</H3>
<PRE>
java.lang.String <B>unkWord</B></PRE>
<DL>
<DD>Some models will use external data sources which contain
 information about unknown words.  This variable is a way to
 provide the name of the unknown word in the external data source.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
lowercaseWordVectors</H3>
<PRE>
boolean <B>lowercaseWordVectors</B></PRE>
<DL>
<DD>Whether or not to lowercase word vectors
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
transformMatrixType</H3>
<PRE>
<A HREF="edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser">TrainOptions.TransformMatrixType</A> <B>transformMatrixType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useContextWords</H3>
<PRE>
boolean <B>useContextWords</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.process</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.process.CoreLabelTokenFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/process/CoreLabelTokenFactory.html" title="class in edu.stanford.nlp.process">edu.stanford.nlp.process.CoreLabelTokenFactory</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
addIndices</H3>
<PRE>
boolean <B>addIndices</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.sequences</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.sequences.PlainTextDocumentReaderAndWriter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/sequences/PlainTextDocumentReaderAndWriter.html" title="class in edu.stanford.nlp.sequences">edu.stanford.nlp.sequences.PlainTextDocumentReaderAndWriter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-2420535144980273136L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
wts</H3>
<PRE>
<A HREF="edu/stanford/nlp/process/WordToSentenceProcessor.html" title="class in edu.stanford.nlp.process">WordToSentenceProcessor</A>&lt;<A HREF="edu/stanford/nlp/process/WordToSentenceProcessor.html" title="type parameter in WordToSentenceProcessor">IN</A>&gt; <B>wts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
flags</H3>
<PRE>
<A HREF="edu/stanford/nlp/sequences/SeqClassifierFlags.html" title="class in edu.stanford.nlp.sequences">SeqClassifierFlags</A> <B>flags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tokenizerFactory</H3>
<PRE>
<A HREF="edu/stanford/nlp/process/TokenizerFactory.html" title="interface in edu.stanford.nlp.process">TokenizerFactory</A>&lt;<A HREF="edu/stanford/nlp/process/TokenizerFactory.html" title="type parameter in TokenizerFactory">T</A>&gt; <B>tokenizerFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.sequences.SeqClassifierFlags"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/sequences/SeqClassifierFlags.html" title="class in edu.stanford.nlp.sequences">edu.stanford.nlp.sequences.SeqClassifierFlags</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7076671761070232567L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
stringRep</H3>
<PRE>
java.lang.String <B>stringRep</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNGrams</H3>
<PRE>
boolean <B>useNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
conjoinShapeNGrams</H3>
<PRE>
boolean <B>conjoinShapeNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lowercaseNGrams</H3>
<PRE>
boolean <B>lowercaseNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dehyphenateNGrams</H3>
<PRE>
boolean <B>dehyphenateNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrev</H3>
<PRE>
boolean <B>usePrev</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNext</H3>
<PRE>
boolean <B>useNext</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTags</H3>
<PRE>
boolean <B>useTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordPairs</H3>
<PRE>
boolean <B>useWordPairs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGazettes</H3>
<PRE>
boolean <B>useGazettes</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSequences</H3>
<PRE>
boolean <B>useSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrevSequences</H3>
<PRE>
boolean <B>usePrevSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNextSequences</H3>
<PRE>
boolean <B>useNextSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLongSequences</H3>
<PRE>
boolean <B>useLongSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useBoundarySequences</H3>
<PRE>
boolean <B>useBoundarySequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTaggySequences</H3>
<PRE>
boolean <B>useTaggySequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useExtraTaggySequences</H3>
<PRE>
boolean <B>useExtraTaggySequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dontExtendTaggy</H3>
<PRE>
boolean <B>dontExtendTaggy</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTaggySequencesShapeInteraction</H3>
<PRE>
boolean <B>useTaggySequencesShapeInteraction</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
strictlyZeroethOrder</H3>
<PRE>
boolean <B>strictlyZeroethOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
strictlyFirstOrder</H3>
<PRE>
boolean <B>strictlyFirstOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
strictlySecondOrder</H3>
<PRE>
boolean <B>strictlySecondOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
strictlyThirdOrder</H3>
<PRE>
boolean <B>strictlyThirdOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
entitySubclassification</H3>
<PRE>
java.lang.String <B>entitySubclassification</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
retainEntitySubclassification</H3>
<PRE>
boolean <B>retainEntitySubclassification</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGazettePhrases</H3>
<PRE>
boolean <B>useGazettePhrases</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
makeConsistent</H3>
<PRE>
boolean <B>makeConsistent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordLabelCounts</H3>
<PRE>
boolean <B>useWordLabelCounts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useViterbi</H3>
<PRE>
boolean <B>useViterbi</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
binnedLengths</H3>
<PRE>
int[] <B>binnedLengths</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
verboseMode</H3>
<PRE>
boolean <B>verboseMode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSum</H3>
<PRE>
boolean <B>useSum</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tolerance</H3>
<PRE>
double <B>tolerance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printFeatures</H3>
<PRE>
java.lang.String <B>printFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSymTags</H3>
<PRE>
boolean <B>useSymTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSymWordPairs</H3>
<PRE>
boolean <B>useSymWordPairs</B></PRE>
<DL>
<DD>useSymWordPairs Has a small negative effect.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
printClassifier</H3>
<PRE>
java.lang.String <B>printClassifier</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printClassifierParam</H3>
<PRE>
int <B>printClassifierParam</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
intern</H3>
<PRE>
boolean <B>intern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
intern2</H3>
<PRE>
boolean <B>intern2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selfTest</H3>
<PRE>
boolean <B>selfTest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sloppyGazette</H3>
<PRE>
boolean <B>sloppyGazette</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
cleanGazette</H3>
<PRE>
boolean <B>cleanGazette</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
noMidNGrams</H3>
<PRE>
boolean <B>noMidNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxNGramLeng</H3>
<PRE>
int <B>maxNGramLeng</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useReverse</H3>
<PRE>
boolean <B>useReverse</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
greekifyNGrams</H3>
<PRE>
boolean <B>greekifyNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useParenMatching</H3>
<PRE>
boolean <B>useParenMatching</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLemmas</H3>
<PRE>
boolean <B>useLemmas</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrevNextLemmas</H3>
<PRE>
boolean <B>usePrevNextLemmas</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
normalizeTerms</H3>
<PRE>
boolean <B>normalizeTerms</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
normalizeTimex</H3>
<PRE>
boolean <B>normalizeTimex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNB</H3>
<PRE>
boolean <B>useNB</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useQN</H3>
<PRE>
boolean <B>useQN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFloat</H3>
<PRE>
boolean <B>useFloat</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
QNsize</H3>
<PRE>
int <B>QNsize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
QNsize2</H3>
<PRE>
int <B>QNsize2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxIterations</H3>
<PRE>
int <B>maxIterations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordShape</H3>
<PRE>
int <B>wordShape</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeStrings</H3>
<PRE>
boolean <B>useShapeStrings</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTypeSeqs</H3>
<PRE>
boolean <B>useTypeSeqs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTypeSeqs2</H3>
<PRE>
boolean <B>useTypeSeqs2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTypeSeqs3</H3>
<PRE>
boolean <B>useTypeSeqs3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDisjunctive</H3>
<PRE>
boolean <B>useDisjunctive</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
disjunctionWidth</H3>
<PRE>
int <B>disjunctionWidth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDisjunctiveShapeInteraction</H3>
<PRE>
boolean <B>useDisjunctiveShapeInteraction</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDisjShape</H3>
<PRE>
boolean <B>useDisjShape</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWord</H3>
<PRE>
boolean <B>useWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useClassFeature</H3>
<PRE>
boolean <B>useClassFeature</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeConjunctions</H3>
<PRE>
boolean <B>useShapeConjunctions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordTag</H3>
<PRE>
boolean <B>useWordTag</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNPHead</H3>
<PRE>
boolean <B>useNPHead</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNPGovernor</H3>
<PRE>
boolean <B>useNPGovernor</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHeadGov</H3>
<PRE>
boolean <B>useHeadGov</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLastRealWord</H3>
<PRE>
boolean <B>useLastRealWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNextRealWord</H3>
<PRE>
boolean <B>useNextRealWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOccurrencePatterns</H3>
<PRE>
boolean <B>useOccurrencePatterns</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTypeySequences</H3>
<PRE>
boolean <B>useTypeySequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
justify</H3>
<PRE>
boolean <B>justify</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
normalize</H3>
<PRE>
boolean <B>normalize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
priorType</H3>
<PRE>
java.lang.String <B>priorType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sigma</H3>
<PRE>
double <B>sigma</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
epsilon</H3>
<PRE>
double <B>epsilon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
beamSize</H3>
<PRE>
int <B>beamSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxLeft</H3>
<PRE>
int <B>maxLeft</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxRight</H3>
<PRE>
int <B>maxRight</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePosition</H3>
<PRE>
boolean <B>usePosition</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useBeginSent</H3>
<PRE>
boolean <B>useBeginSent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGazFeatures</H3>
<PRE>
boolean <B>useGazFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMoreGazFeatures</H3>
<PRE>
boolean <B>useMoreGazFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAbbr</H3>
<PRE>
boolean <B>useAbbr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMinimalAbbr</H3>
<PRE>
boolean <B>useMinimalAbbr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAbbr1</H3>
<PRE>
boolean <B>useAbbr1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMinimalAbbr1</H3>
<PRE>
boolean <B>useMinimalAbbr1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMoreAbbr</H3>
<PRE>
boolean <B>useMoreAbbr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
deleteBlankLines</H3>
<PRE>
boolean <B>deleteBlankLines</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGENIA</H3>
<PRE>
boolean <B>useGENIA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTOK</H3>
<PRE>
boolean <B>useTOK</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useABSTR</H3>
<PRE>
boolean <B>useABSTR</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useABSTRFreqDict</H3>
<PRE>
boolean <B>useABSTRFreqDict</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useABSTRFreq</H3>
<PRE>
boolean <B>useABSTRFreq</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFREQ</H3>
<PRE>
boolean <B>useFREQ</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useABGENE</H3>
<PRE>
boolean <B>useABGENE</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWEB</H3>
<PRE>
boolean <B>useWEB</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWEBFreqDict</H3>
<PRE>
boolean <B>useWEBFreqDict</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useIsURL</H3>
<PRE>
boolean <B>useIsURL</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useURLSequences</H3>
<PRE>
boolean <B>useURLSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useIsDateRange</H3>
<PRE>
boolean <B>useIsDateRange</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEntityTypes</H3>
<PRE>
boolean <B>useEntityTypes</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEntityTypeSequences</H3>
<PRE>
boolean <B>useEntityTypeSequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEntityRule</H3>
<PRE>
boolean <B>useEntityRule</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOrdinal</H3>
<PRE>
boolean <B>useOrdinal</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useACR</H3>
<PRE>
boolean <B>useACR</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useANTE</H3>
<PRE>
boolean <B>useANTE</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMoreTags</H3>
<PRE>
boolean <B>useMoreTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useChunks</H3>
<PRE>
boolean <B>useChunks</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useChunkySequences</H3>
<PRE>
boolean <B>useChunkySequences</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrevVB</H3>
<PRE>
boolean <B>usePrevVB</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNextVB</H3>
<PRE>
boolean <B>useNextVB</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useVB</H3>
<PRE>
boolean <B>useVB</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
subCWGaz</H3>
<PRE>
boolean <B>subCWGaz</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
documentReader</H3>
<PRE>
java.lang.String <B>documentReader</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
map</H3>
<PRE>
java.lang.String <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWideDisjunctive</H3>
<PRE>
boolean <B>useWideDisjunctive</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wideDisjunctionWidth</H3>
<PRE>
int <B>wideDisjunctionWidth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRadical</H3>
<PRE>
boolean <B>useRadical</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useBigramInTwoClique</H3>
<PRE>
boolean <B>useBigramInTwoClique</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
morphFeatureFile</H3>
<PRE>
java.lang.String <B>morphFeatureFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useReverseAffix</H3>
<PRE>
boolean <B>useReverseAffix</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
charHalfWindow</H3>
<PRE>
int <B>charHalfWindow</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWord1</H3>
<PRE>
boolean <B>useWord1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWord2</H3>
<PRE>
boolean <B>useWord2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWord3</H3>
<PRE>
boolean <B>useWord3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWord4</H3>
<PRE>
boolean <B>useWord4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRad1</H3>
<PRE>
boolean <B>useRad1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRad2</H3>
<PRE>
boolean <B>useRad2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordn</H3>
<PRE>
boolean <B>useWordn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCTBPre1</H3>
<PRE>
boolean <B>useCTBPre1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCTBSuf1</H3>
<PRE>
boolean <B>useCTBSuf1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useASBCPre1</H3>
<PRE>
boolean <B>useASBCPre1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useASBCSuf1</H3>
<PRE>
boolean <B>useASBCSuf1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePKPre1</H3>
<PRE>
boolean <B>usePKPre1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePKSuf1</H3>
<PRE>
boolean <B>usePKSuf1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHKPre1</H3>
<PRE>
boolean <B>useHKPre1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHKSuf1</H3>
<PRE>
boolean <B>useHKSuf1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCTBChar2</H3>
<PRE>
boolean <B>useCTBChar2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useASBCChar2</H3>
<PRE>
boolean <B>useASBCChar2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHKChar2</H3>
<PRE>
boolean <B>useHKChar2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePKChar2</H3>
<PRE>
boolean <B>usePKChar2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRule2</H3>
<PRE>
boolean <B>useRule2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDict2</H3>
<PRE>
boolean <B>useDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOutDict2</H3>
<PRE>
boolean <B>useOutDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outDict2</H3>
<PRE>
java.lang.String <B>outDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictleng</H3>
<PRE>
boolean <B>useDictleng</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictCTB2</H3>
<PRE>
boolean <B>useDictCTB2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictASBC2</H3>
<PRE>
boolean <B>useDictASBC2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictPK2</H3>
<PRE>
boolean <B>useDictPK2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictHK2</H3>
<PRE>
boolean <B>useDictHK2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useBig5</H3>
<PRE>
boolean <B>useBig5</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegDict2</H3>
<PRE>
boolean <B>useNegDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegDict3</H3>
<PRE>
boolean <B>useNegDict3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegDict4</H3>
<PRE>
boolean <B>useNegDict4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegCTBDict2</H3>
<PRE>
boolean <B>useNegCTBDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegCTBDict3</H3>
<PRE>
boolean <B>useNegCTBDict3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegCTBDict4</H3>
<PRE>
boolean <B>useNegCTBDict4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegASBCDict2</H3>
<PRE>
boolean <B>useNegASBCDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegASBCDict3</H3>
<PRE>
boolean <B>useNegASBCDict3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegASBCDict4</H3>
<PRE>
boolean <B>useNegASBCDict4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegHKDict2</H3>
<PRE>
boolean <B>useNegHKDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegHKDict3</H3>
<PRE>
boolean <B>useNegHKDict3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegHKDict4</H3>
<PRE>
boolean <B>useNegHKDict4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegPKDict2</H3>
<PRE>
boolean <B>useNegPKDict2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegPKDict3</H3>
<PRE>
boolean <B>useNegPKDict3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNegPKDict4</H3>
<PRE>
boolean <B>useNegPKDict4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePre</H3>
<PRE>
boolean <B>usePre</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSuf</H3>
<PRE>
boolean <B>useSuf</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRule</H3>
<PRE>
boolean <B>useRule</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHk</H3>
<PRE>
boolean <B>useHk</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMsr</H3>
<PRE>
boolean <B>useMsr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMSRChar2</H3>
<PRE>
boolean <B>useMSRChar2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePk</H3>
<PRE>
boolean <B>usePk</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAs</H3>
<PRE>
boolean <B>useAs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFilter</H3>
<PRE>
boolean <B>useFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
largeChSegFile</H3>
<PRE>
boolean <B>largeChSegFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRad2b</H3>
<PRE>
boolean <B>useRad2b</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
keepEnglishWhitespaces</H3>
<PRE>
boolean <B>keepEnglishWhitespaces</B></PRE>
<DL>
<DD>Keep the whitespace between English words in testFile when printing out
 answers. Doesn't really change the content of the CoreLabels. (For Chinese
 segmentation.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
keepAllWhitespaces</H3>
<PRE>
boolean <B>keepAllWhitespaces</B></PRE>
<DL>
<DD>Keep all the whitespace words in testFile when printing out answers.
 Doesn't really change the content of the CoreLabels. (For Chinese
 segmentation.)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
sighanPostProcessing</H3>
<PRE>
boolean <B>sighanPostProcessing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useChPos</H3>
<PRE>
boolean <B>useChPos</B></PRE>
<DL>
<DD>use POS information (an "open" feature for Chinese segmentation)
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
normalizationTable</H3>
<PRE>
java.lang.String <B>normalizationTable</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dictionary</H3>
<PRE>
java.lang.String <B>dictionary</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
serializedDictionary</H3>
<PRE>
java.lang.String <B>serializedDictionary</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dictionary2</H3>
<PRE>
java.lang.String <B>dictionary2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
normTableEncoding</H3>
<PRE>
java.lang.String <B>normTableEncoding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sighanCorporaDict</H3>
<PRE>
java.lang.String <B>sighanCorporaDict</B></PRE>
<DL>
<DD>for Sighan bakeoff 2005, the path to the dictionary of bigrams appeared in
 corpus
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordShapeGaz</H3>
<PRE>
boolean <B>useWordShapeGaz</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordShapeGaz</H3>
<PRE>
java.lang.String <B>wordShapeGaz</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitDocuments</H3>
<PRE>
boolean <B>splitDocuments</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printXML</H3>
<PRE>
boolean <B>printXML</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSeenFeaturesOnly</H3>
<PRE>
boolean <B>useSeenFeaturesOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lastNameList</H3>
<PRE>
java.lang.String <B>lastNameList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maleNameList</H3>
<PRE>
java.lang.String <B>maleNameList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
femaleNameList</H3>
<PRE>
java.lang.String <B>femaleNameList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
inputEncoding</H3>
<PRE>
java.lang.String <B>inputEncoding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bioSubmitOutput</H3>
<PRE>
boolean <B>bioSubmitOutput</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numRuns</H3>
<PRE>
int <B>numRuns</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
answerFile</H3>
<PRE>
java.lang.String <B>answerFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
altAnswerFile</H3>
<PRE>
java.lang.String <B>altAnswerFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dropGaz</H3>
<PRE>
java.lang.String <B>dropGaz</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printGazFeatures</H3>
<PRE>
java.lang.String <B>printGazFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numStartLayers</H3>
<PRE>
int <B>numStartLayers</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dump</H3>
<PRE>
boolean <B>dump</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mergeTags</H3>
<PRE>
boolean <B>mergeTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitOnHead</H3>
<PRE>
boolean <B>splitOnHead</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureCountThreshold</H3>
<PRE>
int <B>featureCountThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureWeightThreshold</H3>
<PRE>
double <B>featureWeightThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureFactory</H3>
<PRE>
java.lang.String <B>featureFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureFactoryArgs</H3>
<PRE>
java.lang.Object[] <B>featureFactoryArgs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
backgroundSymbol</H3>
<PRE>
java.lang.String <B>backgroundSymbol</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useObservedSequencesOnly</H3>
<PRE>
boolean <B>useObservedSequencesOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxDocSize</H3>
<PRE>
int <B>maxDocSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printProbs</H3>
<PRE>
boolean <B>printProbs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printFirstOrderProbs</H3>
<PRE>
boolean <B>printFirstOrderProbs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
saveFeatureIndexToDisk</H3>
<PRE>
boolean <B>saveFeatureIndexToDisk</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
removeBackgroundSingletonFeatures</H3>
<PRE>
boolean <B>removeBackgroundSingletonFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
doGibbs</H3>
<PRE>
boolean <B>doGibbs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numSamples</H3>
<PRE>
int <B>numSamples</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNERPrior</H3>
<PRE>
boolean <B>useNERPrior</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAcqPrior</H3>
<PRE>
boolean <B>useAcqPrior</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUniformPrior</H3>
<PRE>
boolean <B>useUniformPrior</B></PRE>
<DL>
<DD>If true and doGibbs also true, will do generic Gibbs inference without any
 priors
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useMUCFeatures</H3>
<PRE>
boolean <B>useMUCFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
annealingRate</H3>
<PRE>
double <B>annealingRate</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
annealingType</H3>
<PRE>
java.lang.String <B>annealingType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
loadProcessedData</H3>
<PRE>
java.lang.String <B>loadProcessedData</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
initViterbi</H3>
<PRE>
boolean <B>initViterbi</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnknown</H3>
<PRE>
boolean <B>useUnknown</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
checkNameList</H3>
<PRE>
boolean <B>checkNameList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSemPrior</H3>
<PRE>
boolean <B>useSemPrior</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFirstWord</H3>
<PRE>
boolean <B>useFirstWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNumberFeature</H3>
<PRE>
boolean <B>useNumberFeature</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
ocrFold</H3>
<PRE>
int <B>ocrFold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
classifierType</H3>
<PRE>
java.lang.String <B>classifierType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
svmModelFile</H3>
<PRE>
java.lang.String <B>svmModelFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
inferenceType</H3>
<PRE>
java.lang.String <B>inferenceType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLemmaAsWord</H3>
<PRE>
boolean <B>useLemmaAsWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
type</H3>
<PRE>
java.lang.String <B>type</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
readerAndWriter</H3>
<PRE>
java.lang.String <B>readerAndWriter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
comboProps</H3>
<PRE>
java.util.List&lt;E&gt; <B>comboProps</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrediction</H3>
<PRE>
boolean <B>usePrediction</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAltGazFeatures</H3>
<PRE>
boolean <B>useAltGazFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
gazFilesFile</H3>
<PRE>
java.lang.String <B>gazFilesFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePrediction2</H3>
<PRE>
boolean <B>usePrediction2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
baseTrainDir</H3>
<PRE>
java.lang.String <B>baseTrainDir</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
baseTestDir</H3>
<PRE>
java.lang.String <B>baseTestDir</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainFiles</H3>
<PRE>
java.lang.String <B>trainFiles</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainFileList</H3>
<PRE>
java.lang.String <B>trainFileList</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testFiles</H3>
<PRE>
java.lang.String <B>testFiles</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainDirs</H3>
<PRE>
java.lang.String <B>trainDirs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testDirs</H3>
<PRE>
java.lang.String <B>testDirs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOnlySeenWeights</H3>
<PRE>
boolean <B>useOnlySeenWeights</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
predProp</H3>
<PRE>
java.lang.String <B>predProp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
pad</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/CoreLabel.html" title="class in edu.stanford.nlp.ling">CoreLabel</A> <B>pad</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useObservedFeaturesOnly</H3>
<PRE>
boolean <B>useObservedFeaturesOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
distSimLexicon</H3>
<PRE>
java.lang.String <B>distSimLexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDistSim</H3>
<PRE>
boolean <B>useDistSim</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
removeTopN</H3>
<PRE>
int <B>removeTopN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numTimesRemoveTopN</H3>
<PRE>
int <B>numTimesRemoveTopN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
randomizedRatio</H3>
<PRE>
double <B>randomizedRatio</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
removeTopNPercent</H3>
<PRE>
double <B>removeTopNPercent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
purgeFeatures</H3>
<PRE>
int <B>purgeFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
booleanFeatures</H3>
<PRE>
boolean <B>booleanFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
iobWrapper</H3>
<PRE>
boolean <B>iobWrapper</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
iobTags</H3>
<PRE>
boolean <B>iobTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSegmentation</H3>
<PRE>
boolean <B>useSegmentation</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
memoryThrift</H3>
<PRE>
boolean <B>memoryThrift</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
timitDatum</H3>
<PRE>
boolean <B>timitDatum</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
serializeDatasetsDir</H3>
<PRE>
java.lang.String <B>serializeDatasetsDir</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
loadDatasetsDir</H3>
<PRE>
java.lang.String <B>loadDatasetsDir</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
pushDir</H3>
<PRE>
java.lang.String <B>pushDir</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
purgeDatasets</H3>
<PRE>
boolean <B>purgeDatasets</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
keepOBInMemory</H3>
<PRE>
boolean <B>keepOBInMemory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
fakeDataset</H3>
<PRE>
boolean <B>fakeDataset</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
restrictTransitionsTimit</H3>
<PRE>
boolean <B>restrictTransitionsTimit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numDatasetsPerFile</H3>
<PRE>
int <B>numDatasetsPerFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTitle</H3>
<PRE>
boolean <B>useTitle</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
lowerNewgeneThreshold</H3>
<PRE>
boolean <B>lowerNewgeneThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEitherSideWord</H3>
<PRE>
boolean <B>useEitherSideWord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEitherSideDisjunctive</H3>
<PRE>
boolean <B>useEitherSideDisjunctive</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
twoStage</H3>
<PRE>
boolean <B>twoStage</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
crfType</H3>
<PRE>
java.lang.String <B>crfType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureThreshold</H3>
<PRE>
int <B>featureThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featThreshFile</H3>
<PRE>
java.lang.String <B>featThreshFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
featureDiffThresh</H3>
<PRE>
double <B>featureDiffThresh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numTimesPruneFeatures</H3>
<PRE>
int <B>numTimesPruneFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
newgeneThreshold</H3>
<PRE>
double <B>newgeneThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
doAdaptation</H3>
<PRE>
boolean <B>doAdaptation</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useInternal</H3>
<PRE>
boolean <B>useInternal</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useExternal</H3>
<PRE>
boolean <B>useExternal</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selfTrainConfidenceThreshold</H3>
<PRE>
double <B>selfTrainConfidenceThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selfTrainIterations</H3>
<PRE>
int <B>selfTrainIterations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
selfTrainWindowSize</H3>
<PRE>
int <B>selfTrainWindowSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHuber</H3>
<PRE>
boolean <B>useHuber</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useQuartic</H3>
<PRE>
boolean <B>useQuartic</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
adaptSigma</H3>
<PRE>
double <B>adaptSigma</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numFolds</H3>
<PRE>
int <B>numFolds</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
startFold</H3>
<PRE>
int <B>startFold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
endFold</H3>
<PRE>
int <B>endFold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
cacheNGrams</H3>
<PRE>
boolean <B>cacheNGrams</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outputFormat</H3>
<PRE>
java.lang.String <B>outputFormat</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSMD</H3>
<PRE>
boolean <B>useSMD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSGDtoQN</H3>
<PRE>
boolean <B>useSGDtoQN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useStochasticQN</H3>
<PRE>
boolean <B>useStochasticQN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useScaledSGD</H3>
<PRE>
boolean <B>useScaledSGD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
scaledSGDMethod</H3>
<PRE>
int <B>scaledSGDMethod</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
SGDPasses</H3>
<PRE>
int <B>SGDPasses</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
QNPasses</H3>
<PRE>
int <B>QNPasses</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tuneSGD</H3>
<PRE>
boolean <B>tuneSGD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
stochasticMethod</H3>
<PRE>
<A HREF="edu/stanford/nlp/optimization/StochasticCalculateMethods.html" title="enum in edu.stanford.nlp.optimization">StochasticCalculateMethods</A> <B>stochasticMethod</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
initialGain</H3>
<PRE>
double <B>initialGain</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
stochasticBatchSize</H3>
<PRE>
int <B>stochasticBatchSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSGD</H3>
<PRE>
boolean <B>useSGD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
gainSGD</H3>
<PRE>
double <B>gainSGD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHybrid</H3>
<PRE>
boolean <B>useHybrid</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
hybridCutoffIteration</H3>
<PRE>
int <B>hybridCutoffIteration</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outputIterationsToFile</H3>
<PRE>
boolean <B>outputIterationsToFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testObjFunction</H3>
<PRE>
boolean <B>testObjFunction</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testVariance</H3>
<PRE>
boolean <B>testVariance</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
SGD2QNhessSamples</H3>
<PRE>
int <B>SGD2QNhessSamples</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
testHessSamples</H3>
<PRE>
boolean <B>testHessSamples</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
CRForder</H3>
<PRE>
int <B>CRForder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
CRFwindow</H3>
<PRE>
int <B>CRFwindow</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
estimateInitial</H3>
<PRE>
boolean <B>estimateInitial</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outputEncoding</H3>
<PRE>
java.lang.String <B>outputEncoding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useKBest</H3>
<PRE>
boolean <B>useKBest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
searchGraphPrefix</H3>
<PRE>
java.lang.String <B>searchGraphPrefix</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
searchGraphPrune</H3>
<PRE>
double <B>searchGraphPrune</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
kBest</H3>
<PRE>
int <B>kBest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesC4gram</H3>
<PRE>
boolean <B>useFeaturesC4gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesC5gram</H3>
<PRE>
boolean <B>useFeaturesC5gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesC6gram</H3>
<PRE>
boolean <B>useFeaturesC6gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesCpC4gram</H3>
<PRE>
boolean <B>useFeaturesCpC4gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesCpC5gram</H3>
<PRE>
boolean <B>useFeaturesCpC5gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFeaturesCpC6gram</H3>
<PRE>
boolean <B>useFeaturesCpC6gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnicodeType</H3>
<PRE>
boolean <B>useUnicodeType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnicodeType4gram</H3>
<PRE>
boolean <B>useUnicodeType4gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnicodeType5gram</H3>
<PRE>
boolean <B>useUnicodeType5gram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
use4Clique</H3>
<PRE>
boolean <B>use4Clique</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useUnicodeBlock</H3>
<PRE>
boolean <B>useUnicodeBlock</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeStrings1</H3>
<PRE>
boolean <B>useShapeStrings1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeStrings3</H3>
<PRE>
boolean <B>useShapeStrings3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeStrings4</H3>
<PRE>
boolean <B>useShapeStrings4</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useShapeStrings5</H3>
<PRE>
boolean <B>useShapeStrings5</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGoodForNamesCpC</H3>
<PRE>
boolean <B>useGoodForNamesCpC</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictionaryConjunctions</H3>
<PRE>
boolean <B>useDictionaryConjunctions</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
expandMidDot</H3>
<PRE>
boolean <B>expandMidDot</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printFeaturesUpto</H3>
<PRE>
int <B>printFeaturesUpto</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useDictionaryConjunctions3</H3>
<PRE>
boolean <B>useDictionaryConjunctions3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordUTypeConjunctions2</H3>
<PRE>
boolean <B>useWordUTypeConjunctions2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordUTypeConjunctions3</H3>
<PRE>
boolean <B>useWordUTypeConjunctions3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordShapeConjunctions2</H3>
<PRE>
boolean <B>useWordShapeConjunctions2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordShapeConjunctions3</H3>
<PRE>
boolean <B>useWordShapeConjunctions3</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMidDotShape</H3>
<PRE>
boolean <B>useMidDotShape</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
augmentedDateChars</H3>
<PRE>
boolean <B>augmentedDateChars</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
suppressMidDotPostprocessing</H3>
<PRE>
boolean <B>suppressMidDotPostprocessing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printNR</H3>
<PRE>
boolean <B>printNR</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
classBias</H3>
<PRE>
java.lang.String <B>classBias</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printLabelValue</H3>
<PRE>
boolean <B>printLabelValue</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useRobustQN</H3>
<PRE>
boolean <B>useRobustQN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
combo</H3>
<PRE>
boolean <B>combo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useGenericFeatures</H3>
<PRE>
boolean <B>useGenericFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
verboseForTrueCasing</H3>
<PRE>
boolean <B>verboseForTrueCasing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
trainHierarchical</H3>
<PRE>
java.lang.String <B>trainHierarchical</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
domain</H3>
<PRE>
java.lang.String <B>domain</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
baseline</H3>
<PRE>
boolean <B>baseline</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
transferSigmas</H3>
<PRE>
java.lang.String <B>transferSigmas</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
doFE</H3>
<PRE>
boolean <B>doFE</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
restrictLabels</H3>
<PRE>
boolean <B>restrictLabels</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
announceObjectBankEntries</H3>
<PRE>
boolean <B>announceObjectBankEntries</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePos</H3>
<PRE>
boolean <B>usePos</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAgreement</H3>
<PRE>
boolean <B>useAgreement</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAccCase</H3>
<PRE>
boolean <B>useAccCase</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useInna</H3>
<PRE>
boolean <B>useInna</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useConcord</H3>
<PRE>
boolean <B>useConcord</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useFirstNgram</H3>
<PRE>
boolean <B>useFirstNgram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLastNgram</H3>
<PRE>
boolean <B>useLastNgram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
collapseNN</H3>
<PRE>
boolean <B>collapseNN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useConjBreak</H3>
<PRE>
boolean <B>useConjBreak</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAuxPairs</H3>
<PRE>
boolean <B>useAuxPairs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePPVBPairs</H3>
<PRE>
boolean <B>usePPVBPairs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAnnexing</H3>
<PRE>
boolean <B>useAnnexing</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTemporalNN</H3>
<PRE>
boolean <B>useTemporalNN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePath</H3>
<PRE>
boolean <B>usePath</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
innaPPAttach</H3>
<PRE>
boolean <B>innaPPAttach</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
markProperNN</H3>
<PRE>
boolean <B>markProperNN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
markMasdar</H3>
<PRE>
boolean <B>markMasdar</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSVO</H3>
<PRE>
boolean <B>useSVO</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numTags</H3>
<PRE>
int <B>numTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTagsCpC</H3>
<PRE>
boolean <B>useTagsCpC</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTagsCpCp2C</H3>
<PRE>
boolean <B>useTagsCpCp2C</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTagsCpCp2Cp3C</H3>
<PRE>
boolean <B>useTagsCpCp2Cp3C</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTagsCpCp2Cp3Cp4C</H3>
<PRE>
boolean <B>useTagsCpCp2Cp3Cp4C</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
l1reg</H3>
<PRE>
double <B>l1reg</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mixedCaseMapFile</H3>
<PRE>
java.lang.String <B>mixedCaseMapFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
auxTrueCaseModels</H3>
<PRE>
java.lang.String <B>auxTrueCaseModels</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
use2W</H3>
<PRE>
boolean <B>use2W</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLC</H3>
<PRE>
boolean <B>useLC</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useYetMoreCpCShapes</H3>
<PRE>
boolean <B>useYetMoreCpCShapes</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useIfInteger</H3>
<PRE>
boolean <B>useIfInteger</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
exportFeatures</H3>
<PRE>
java.lang.String <B>exportFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useInPlaceSGD</H3>
<PRE>
boolean <B>useInPlaceSGD</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTopics</H3>
<PRE>
boolean <B>useTopics</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
evaluateIters</H3>
<PRE>
int <B>evaluateIters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
evalCmd</H3>
<PRE>
java.lang.String <B>evalCmd</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
evaluateTrain</H3>
<PRE>
boolean <B>evaluateTrain</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tuneSampleSize</H3>
<PRE>
int <B>tuneSampleSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePhraseFeatures</H3>
<PRE>
boolean <B>usePhraseFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePhraseWords</H3>
<PRE>
boolean <B>usePhraseWords</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePhraseWordTags</H3>
<PRE>
boolean <B>usePhraseWordTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
usePhraseWordSpecialTags</H3>
<PRE>
boolean <B>usePhraseWordSpecialTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCommonWordsFeature</H3>
<PRE>
boolean <B>useCommonWordsFeature</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useProtoFeatures</H3>
<PRE>
boolean <B>useProtoFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useWordnetFeatures</H3>
<PRE>
boolean <B>useWordnetFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tokenFactory</H3>
<PRE>
java.lang.String <B>tokenFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tokenFactoryArgs</H3>
<PRE>
java.lang.Object[] <B>tokenFactoryArgs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tokensAnnotationClassName</H3>
<PRE>
java.lang.String <B>tokensAnnotationClassName</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCorefFeatures</H3>
<PRE>
boolean <B>useCorefFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wikiFeatureDbFile</H3>
<PRE>
java.lang.String <B>wikiFeatureDbFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNoisyNonNoisyFeature</H3>
<PRE>
boolean <B>useNoisyNonNoisyFeature</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useYear</H3>
<PRE>
boolean <B>useYear</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSentenceNumber</H3>
<PRE>
boolean <B>useSentenceNumber</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useLabelSource</H3>
<PRE>
boolean <B>useLabelSource</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
casedDistSim</H3>
<PRE>
boolean <B>casedDistSim</B></PRE>
<DL>
<DD>Whether to (not) lowercase tokens before looking them up in distsim
 lexicon. By default lowercasing was done, but now it doesn't have to be
 true :-).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
distSimFileFormat</H3>
<PRE>
java.lang.String <B>distSimFileFormat</B></PRE>
<DL>
<DD>The format of the distsim file. Known values are: alexClark = TSV file.
 word TAB clusterNumber [optional other content] terryKoo = TSV file.
 clusterBitString TAB word TAB frequency
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
distSimMaxBits</H3>
<PRE>
int <B>distSimMaxBits</B></PRE>
<DL>
<DD>If this number is greater than 0, the distSim class is assume to be a bit
 string and is truncated at this many characters. Normal distSim features
 will then use this amount of resolution. Extra, special distsim features
 may work at a coarser level of resolution. Since the lexicon only stores
 this length of bit string, there is then no way to have finer-grained
 clusters.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
numberEquivalenceDistSim</H3>
<PRE>
boolean <B>numberEquivalenceDistSim</B></PRE>
<DL>
<DD>If this is set to true, all digit characters get mapped to '9' in a distsim
 lexicon and for lookup. This is a simple word shaping that can shrink
 distsim lexicons and improve their performance.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
unknownWordDistSimClass</H3>
<PRE>
java.lang.String <B>unknownWordDistSimClass</B></PRE>
<DL>
<DD>What class to assign to words not found in the dist sim lexicon. You might
 want to make it a known class, if one is the "default class.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useNeighborNGrams</H3>
<PRE>
boolean <B>useNeighborNGrams</B></PRE>
<DL>
<DD>Use prefixes and suffixes from the previous and next word.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
wordFunction</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Function.html" title="interface in edu.stanford.nlp.util">Function</A>&lt;<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T1</A>,<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T2</A>&gt; <B>wordFunction</B></PRE>
<DL>
<DD>This function maps words in the training or test data to new
 words.  They are used at the feature extractor level, ie in the
 FeatureFactory.  For now, only the NERFeatureFactory uses this.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
plainTextDocumentReaderAndWriter</H3>
<PRE>
java.lang.String <B>plainTextDocumentReaderAndWriter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useBagOfWords</H3>
<PRE>
boolean <B>useBagOfWords</B></PRE>
<DL>
<DD>Use a bag of all words as a feature.  Perhaps this will find some
 words that indicate certain types of entities are present.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
evaluateBackground</H3>
<PRE>
boolean <B>evaluateBackground</B></PRE>
<DL>
<DD>When scoring, count the background symbol stats too.  Useful for
 things where the background symbol is particularly meaningful,
 such as truecase.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
numLopExpert</H3>
<PRE>
int <B>numLopExpert</B></PRE>
<DL>
<DD>Number of experts to be used in Logarithmic Opinion Pool (product of experts) training
 default value is 1
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
includeFullCRFInLOP</H3>
<PRE>
boolean <B>includeFullCRFInLOP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
backpropLopTraining</H3>
<PRE>
boolean <B>backpropLopTraining</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
randomLopWeights</H3>
<PRE>
boolean <B>randomLopWeights</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
randomLopFeatureSplit</H3>
<PRE>
boolean <B>randomLopFeatureSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
nonLinearCRF</H3>
<PRE>
boolean <B>nonLinearCRF</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
secondOrderNonLinear</H3>
<PRE>
boolean <B>secondOrderNonLinear</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numHiddenUnits</H3>
<PRE>
int <B>numHiddenUnits</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOutputLayer</H3>
<PRE>
boolean <B>useOutputLayer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useHiddenLayer</H3>
<PRE>
boolean <B>useHiddenLayer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
gradientDebug</H3>
<PRE>
boolean <B>gradientDebug</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
checkGradient</H3>
<PRE>
boolean <B>checkGradient</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSigmoid</H3>
<PRE>
boolean <B>useSigmoid</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
skipOutputRegularization</H3>
<PRE>
boolean <B>skipOutputRegularization</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sparseOutputLayer</H3>
<PRE>
boolean <B>sparseOutputLayer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tieOutputLayer</H3>
<PRE>
boolean <B>tieOutputLayer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
blockInitialize</H3>
<PRE>
boolean <B>blockInitialize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
softmaxOutputLayer</H3>
<PRE>
boolean <B>softmaxOutputLayer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
loadBisequenceClassifierEn</H3>
<PRE>
java.lang.String <B>loadBisequenceClassifierEn</B></PRE>
<DL>
<DD>Bisequence CRF parameters
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
loadBisequenceClassifierCh</H3>
<PRE>
java.lang.String <B>loadBisequenceClassifierCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceClassifierPropEn</H3>
<PRE>
java.lang.String <B>bisequenceClassifierPropEn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceClassifierPropCh</H3>
<PRE>
java.lang.String <B>bisequenceClassifierPropCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceTestFileEn</H3>
<PRE>
java.lang.String <B>bisequenceTestFileEn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceTestFileCh</H3>
<PRE>
java.lang.String <B>bisequenceTestFileCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceTestOutputEn</H3>
<PRE>
java.lang.String <B>bisequenceTestOutputEn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceTestOutputCh</H3>
<PRE>
java.lang.String <B>bisequenceTestOutputCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceTestAlignmentFile</H3>
<PRE>
java.lang.String <B>bisequenceTestAlignmentFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequencePriorType</H3>
<PRE>
int <B>bisequencePriorType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceAlignmentPriorPenaltyCh</H3>
<PRE>
java.lang.String <B>bisequenceAlignmentPriorPenaltyCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bisequenceAlignmentPriorPenaltyEn</H3>
<PRE>
java.lang.String <B>bisequenceAlignmentPriorPenaltyEn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
alignmentPruneThreshold</H3>
<PRE>
double <B>alignmentPruneThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
factorInAlignmentProb</H3>
<PRE>
boolean <B>factorInAlignmentProb</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useChromaticSampling</H3>
<PRE>
boolean <B>useChromaticSampling</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useSequentialScanSampling</H3>
<PRE>
boolean <B>useSequentialScanSampling</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
maxAllowedChromaticSize</H3>
<PRE>
int <B>maxAllowedChromaticSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
keepEmptySentences</H3>
<PRE>
boolean <B>keepEmptySentences</B></PRE>
<DL>
<DD>Whether or not to keep blank sentences when processing.  Useful
 for systems such as the segmenter if you want to line up each
 line exactly, including blank lines.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
useBilingualNERPrior</H3>
<PRE>
boolean <B>useBilingualNERPrior</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
samplingSpeedUpThreshold</H3>
<PRE>
int <B>samplingSpeedUpThreshold</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
entityMatrixCh</H3>
<PRE>
java.lang.String <B>entityMatrixCh</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
entityMatrixEn</H3>
<PRE>
java.lang.String <B>entityMatrixEn</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
multiThreadGibbs</H3>
<PRE>
int <B>multiThreadGibbs</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
matchNERIncentive</H3>
<PRE>
boolean <B>matchNERIncentive</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useEmbedding</H3>
<PRE>
boolean <B>useEmbedding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
prependEmbedding</H3>
<PRE>
boolean <B>prependEmbedding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
embeddingWords</H3>
<PRE>
java.lang.String <B>embeddingWords</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
embeddingVectors</H3>
<PRE>
java.lang.String <B>embeddingVectors</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
transitionEdgeOnly</H3>
<PRE>
boolean <B>transitionEdgeOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
priorLambda</H3>
<PRE>
double <B>priorLambda</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
addCapitalFeatures</H3>
<PRE>
boolean <B>addCapitalFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
arbitraryInputLayerSize</H3>
<PRE>
int <B>arbitraryInputLayerSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
noEdgeFeature</H3>
<PRE>
boolean <B>noEdgeFeature</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
terminateOnEvalImprovement</H3>
<PRE>
boolean <B>terminateOnEvalImprovement</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
terminateOnEvalImprovementNumOfEpoch</H3>
<PRE>
int <B>terminateOnEvalImprovementNumOfEpoch</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useMemoryEvaluator</H3>
<PRE>
boolean <B>useMemoryEvaluator</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
suppressTestDebug</H3>
<PRE>
boolean <B>suppressTestDebug</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useOWLQN</H3>
<PRE>
boolean <B>useOWLQN</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printWeights</H3>
<PRE>
boolean <B>printWeights</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
totalDataSlice</H3>
<PRE>
int <B>totalDataSlice</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numOfSlices</H3>
<PRE>
int <B>numOfSlices</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
regularizeSoftmaxTieParam</H3>
<PRE>
boolean <B>regularizeSoftmaxTieParam</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
softmaxTieLambda</H3>
<PRE>
double <B>softmaxTieLambda</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
totalFeatureSlice</H3>
<PRE>
int <B>totalFeatureSlice</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
numOfFeatureSlices</H3>
<PRE>
int <B>numOfFeatureSlices</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
addBiasToEmbedding</H3>
<PRE>
boolean <B>addBiasToEmbedding</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
hardcodeSoftmaxOutputWeights</H3>
<PRE>
boolean <B>hardcodeSoftmaxOutputWeights</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useNERPriorBIO</H3>
<PRE>
boolean <B>useNERPriorBIO</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
entityMatrix</H3>
<PRE>
java.lang.String <B>entityMatrix</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
multiThreadClassifier</H3>
<PRE>
int <B>multiThreadClassifier</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
printFactorTable</H3>
<PRE>
boolean <B>printFactorTable</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useAdaGradFOBOS</H3>
<PRE>
boolean <B>useAdaGradFOBOS</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
initRate</H3>
<PRE>
double <B>initRate</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
groupByFeatureTemplate</H3>
<PRE>
boolean <B>groupByFeatureTemplate</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
groupByOutputClass</H3>
<PRE>
boolean <B>groupByOutputClass</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
priorAlpha</H3>
<PRE>
double <B>priorAlpha</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitWordRegex</H3>
<PRE>
java.lang.String <B>splitWordRegex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
groupByInput</H3>
<PRE>
boolean <B>groupByInput</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
groupByHiddenUnit</H3>
<PRE>
boolean <B>groupByHiddenUnit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
unigramLM</H3>
<PRE>
java.lang.String <B>unigramLM</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
bigramLM</H3>
<PRE>
java.lang.String <B>bigramLM</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordSegBeamSize</H3>
<PRE>
int <B>wordSegBeamSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
vocabFile</H3>
<PRE>
java.lang.String <B>vocabFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
averagePerceptron</H3>
<PRE>
boolean <B>averagePerceptron</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
loadCRFSegmenterPath</H3>
<PRE>
java.lang.String <B>loadCRFSegmenterPath</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
loadPCTSegmenterPath</H3>
<PRE>
java.lang.String <B>loadPCTSegmenterPath</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
crfSegmenterProp</H3>
<PRE>
java.lang.String <B>crfSegmenterProp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
pctSegmenterProp</H3>
<PRE>
java.lang.String <B>pctSegmenterProp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
intermediateSegmenterOut</H3>
<PRE>
java.lang.String <B>intermediateSegmenterOut</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
intermediateSegmenterModel</H3>
<PRE>
java.lang.String <B>intermediateSegmenterModel</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dualDecompMaxItr</H3>
<PRE>
int <B>dualDecompMaxItr</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dualDecompInitialStepSize</H3>
<PRE>
double <B>dualDecompInitialStepSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dualDecompDebug</H3>
<PRE>
boolean <B>dualDecompDebug</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCWSWordFeatures</H3>
<PRE>
boolean <B>useCWSWordFeatures</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCWSWordFeaturesAll</H3>
<PRE>
boolean <B>useCWSWordFeaturesAll</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useCWSWordFeaturesBigram</H3>
<PRE>
boolean <B>useCWSWordFeaturesBigram</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
pctSegmenterLenAdjust</H3>
<PRE>
boolean <B>pctSegmenterLenAdjust</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
useTrainLexicon</H3>
<PRE>
boolean <B>useTrainLexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.stats</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.stats.ClassicCounter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/stats/ClassicCounter.html" title="class in edu.stanford.nlp.stats">edu.stanford.nlp.stats.ClassicCounter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mapFactory</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>mapFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
totalCount</H3>
<PRE>
double <B>totalCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultValue</H3>
<PRE>
double <B>defaultValue</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.stats.Distribution"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/stats/Distribution.html" title="class in edu.stanford.nlp.stats">edu.stanford.nlp.stats.Distribution</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>6707148234288637809L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
numberOfKeys</H3>
<PRE>
int <B>numberOfKeys</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
reservedMass</H3>
<PRE>
double <B>reservedMass</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
counter</H3>
<PRE>
<A HREF="edu/stanford/nlp/stats/Counter.html" title="interface in edu.stanford.nlp.stats">Counter</A>&lt;<A HREF="edu/stanford/nlp/stats/Counter.html" title="type parameter in Counter">E</A>&gt; <B>counter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.stats.GeneralizedCounter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/stats/GeneralizedCounter.html" title="class in edu.stanford.nlp.stats">edu.stanford.nlp.stats.GeneralizedCounter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
depth</H3>
<PRE>
int <B>depth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
total</H3>
<PRE>
double <B>total</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.stats.IntCounter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/stats/IntCounter.html" title="class in edu.stanford.nlp.stats">edu.stanford.nlp.stats.IntCounter</A> extends <A HREF="edu/stanford/nlp/stats/AbstractCounter.html" title="class in edu.stanford.nlp.stats">AbstractCounter</A>&lt;<A HREF="edu/stanford/nlp/stats/IntCounter.html" title="type parameter in IntCounter">E</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mapFactory</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>mapFactory</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
totalCount</H3>
<PRE>
int <B>totalCount</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultValue</H3>
<PRE>
int <B>defaultValue</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.stats.TwoDimensionalCounter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/stats/TwoDimensionalCounter.html" title="class in edu.stanford.nlp.stats">edu.stanford.nlp.stats.TwoDimensionalCounter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
total</H3>
<PRE>
double <B>total</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outerMF</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>outerMF</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
innerMF</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>innerMF</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultValue</H3>
<PRE>
double <B>defaultValue</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.tagger.maxent</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.DictionaryExtractor"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/DictionaryExtractor.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.DictionaryExtractor</A> extends <A HREF="edu/stanford/nlp/tagger/maxent/Extractor.html" title="class in edu.stanford.nlp.tagger.maxent">Extractor</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>692763177746328195L

<P>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.Extractor"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/Extractor.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.Extractor</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4694133872973560083L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
position</H3>
<PRE>
int <B>position</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
isTag</H3>
<PRE>
boolean <B>isTag</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.ExtractorDistsim"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/ExtractorDistsim.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.ExtractorDistsim</A> extends <A HREF="edu/stanford/nlp/tagger/maxent/Extractor.html" title="class in edu.stanford.nlp.tagger.maxent">Extractor</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
lexicon</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>lexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.ExtractorDistsim.ExtractorDistsimConjunction"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/ExtractorDistsim.ExtractorDistsimConjunction.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.ExtractorDistsim.ExtractorDistsimConjunction</A> extends <A HREF="edu/stanford/nlp/tagger/maxent/Extractor.html" title="class in edu.stanford.nlp.tagger.maxent">Extractor</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
lexicon</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>lexicon</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
left</H3>
<PRE>
int <B>left</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
right</H3>
<PRE>
int <B>right</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
name</H3>
<PRE>
java.lang.String <B>name</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.Extractors"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/Extractors.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.Extractors</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4777107742414749890L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
v</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/Extractor.html" title="class in edu.stanford.nlp.tagger.maxent">Extractor</A>[] <B>v</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.ExtractorVerbalVBNZero"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/ExtractorVerbalVBNZero.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.ExtractorVerbalVBNZero</A> extends <A HREF="edu/stanford/nlp/tagger/maxent/DictionaryExtractor.html" title="class in edu.stanford.nlp.tagger.maxent">DictionaryExtractor</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5881204185400060636L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
bound</H3>
<PRE>
int <B>bound</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.MaxentTagger"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/MaxentTagger.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.MaxentTagger</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;in)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<HR>
<A NAME="writeObject(java.io.ObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
private void <B>writeObject</B>(java.io.ObjectOutputStream&nbsp;out)
                  throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
dict</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/Dictionary.html" title="class in edu.stanford.nlp.tagger.maxent">Dictionary</A> <B>dict</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tags</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/TTags.html" title="class in edu.stanford.nlp.tagger.maxent">TTags</A> <B>tags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
prob</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/LambdaSolveTagger.html" title="class in edu.stanford.nlp.tagger.maxent">LambdaSolveTagger</A> <B>prob</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
fAssociations</H3>
<PRE>
java.util.List&lt;E&gt; <B>fAssociations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
extractors</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/Extractors.html" title="class in edu.stanford.nlp.tagger.maxent">Extractors</A> <B>extractors</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
extractorsRare</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/Extractors.html" title="class in edu.stanford.nlp.tagger.maxent">Extractors</A> <B>extractorsRare</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
ambClasses</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/AmbiguityClasses.html" title="class in edu.stanford.nlp.tagger.maxent">AmbiguityClasses</A> <B>ambClasses</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
alltags</H3>
<PRE>
boolean <B>alltags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagTokens</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>tagTokens</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultScore</H3>
<PRE>
double <B>defaultScore</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultScores</H3>
<PRE>
double[] <B>defaultScores</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
leftContext</H3>
<PRE>
int <B>leftContext</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
rightContext</H3>
<PRE>
int <B>rightContext</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
config</H3>
<PRE>
<A HREF="edu/stanford/nlp/tagger/maxent/TaggerConfig.html" title="class in edu.stanford.nlp.tagger.maxent">TaggerConfig</A> <B>config</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
rareWordThresh</H3>
<PRE>
int <B>rareWordThresh</B></PRE>
<DL>
<DD>Determines which words are considered rare.  All words with count
 in the training data strictly less than this number (standardly, &lt; 5) are
 considered rare.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
minFeatureThresh</H3>
<PRE>
int <B>minFeatureThresh</B></PRE>
<DL>
<DD>Determines which features are included in the model.  The model
 includes features that occurred strictly more times than this number
 (standardly, &gt; 5) in the training data.  Here I look only at the
 history (not the tag), so the history appearing this often is enough.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
curWordMinFeatureThresh</H3>
<PRE>
int <B>curWordMinFeatureThresh</B></PRE>
<DL>
<DD>This is a special threshold for the current word feature.
 Only words that have occurred strictly &gt; this number of times
 in total will generate word features with all of their occurring tags.
 The traditional default was 2.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
rareWordMinFeatureThresh</H3>
<PRE>
int <B>rareWordMinFeatureThresh</B></PRE>
<DL>
<DD>Determines which rare word features are included in the model.
 The features for rare words have a strictly higher support than
 this number are included. Traditional default is 10.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
veryCommonWordThresh</H3>
<PRE>
int <B>veryCommonWordThresh</B></PRE>
<DL>
<DD>If using tag equivalence classes on following words, words that occur
 strictly more than this number of times (in total with any tag)
 are sufficiently frequent to form an equivalence class
 by themselves. (Not used unless using equivalence classes.)

 There are places in the code (ExtractorAmbiguityClass.java, for one)
 that assume this value is constant over the life of a tagger.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
xSize</H3>
<PRE>
int <B>xSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
ySize</H3>
<PRE>
int <B>ySize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
occurringTagsOnly</H3>
<PRE>
boolean <B>occurringTagsOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
possibleTagsOnly</H3>
<PRE>
boolean <B>possibleTagsOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
initted</H3>
<PRE>
boolean <B>initted</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
VERBOSE</H3>
<PRE>
boolean <B>VERBOSE</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
wordFunction</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Function.html" title="interface in edu.stanford.nlp.util">Function</A>&lt;<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T1</A>,<A HREF="edu/stanford/nlp/util/Function.html" title="type parameter in Function">T2</A>&gt; <B>wordFunction</B></PRE>
<DL>
<DD>This is a function used to preprocess all text before applying
 the tagger to it.  For example, it could be a function to
 lowercase text, such as edu.stanford.nlp.util.LowercaseFunction
 (which makes the tagger case insensitive).  It is applied in
 ReadDataTagged, which loads in the training data, and in
 TestSentence, which processes sentences for new queries.  If any
 other classes are added or modified which use raw text, they must
 also use this function to keep results consistent.
 <br>
 An alternate design would have been to use the function at a
 lower level, such as at the extractor level.  That would have
 require more invasive changes to the tagger, though, because
 other data structures such as the Dictionary would then be using
 raw text as well.  This is also more efficient, in that the
 function is applied once at the start of the process.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.MaxentTaggerGUI"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/MaxentTaggerGUI.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.MaxentTaggerGUI</A> extends javax.swing.JFrame implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-2574711492469740892L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
inputBox</H3>
<PRE>
javax.swing.JTextArea <B>inputBox</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
outputBox</H3>
<PRE>
javax.swing.JTextArea <B>outputBox</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
tagButton</H3>
<PRE>
javax.swing.JButton <B>tagButton</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.tagger.maxent.TaggerConfig"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/tagger/maxent/TaggerConfig.html" title="class in edu.stanford.nlp.tagger.maxent">edu.stanford.nlp.tagger.maxent.TaggerConfig</A> extends java.util.Properties implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4136407850147157497L

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.trees</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.trees.AbstractCollinsHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/AbstractCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.AbstractCollinsHeadFinder</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-6540278059442931087L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tlp</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreebankLanguagePack.html" title="interface in edu.stanford.nlp.trees">TreebankLanguagePack</A> <B>tlp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
nonTerminalInfo</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>nonTerminalInfo</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultRule</H3>
<PRE>
java.lang.String[] <B>defaultRule</B></PRE>
<DL>
<DD>Default direction if no rule is found for category (the head/parent).
  Subclasses can turn it on if they like.
  If they don't it is an error if no rule is defined for a category
  (null is returned).
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultLeftRule</H3>
<PRE>
java.lang.String[] <B>defaultLeftRule</B></PRE>
<DL>
<DD>These are built automatically from categoriesToAvoid and used in a fairly
  different fashion from defaultRule (above).  These are used for categories
  that do have defined rules but where none of them have matched.  Rather
  than picking the rightmost or leftmost child, we will use these to pick
  the the rightmost or leftmost child which isn't in categoriesToAvoid.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
defaultRightRule</H3>
<PRE>
java.lang.String[] <B>defaultRightRule</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.AbstractTreebankLanguagePack"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/AbstractTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.AbstractTreebankLanguagePack</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-6506749780512708352L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
gfCharacter</H3>
<PRE>
char <B>gfCharacter</B></PRE>
<DL>
<DD>Default character for indicating that something is a grammatical fn; probably should be overridden by
 lang specific ones
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
punctTagStringAcceptFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>punctTagStringAcceptFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
punctWordStringAcceptFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>punctWordStringAcceptFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sFPunctTagStringAcceptFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>sFPunctTagStringAcceptFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
eIPunctTagStringAcceptFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>eIPunctTagStringAcceptFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
startSymbolAcceptFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>startSymbolAcceptFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.BobChrisTreeNormalizer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/BobChrisTreeNormalizer.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.BobChrisTreeNormalizer</A> extends <A HREF="edu/stanford/nlp/trees/TreeNormalizer.html" title="class in edu.stanford.nlp.trees">TreeNormalizer</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1005188028979810143L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tlp</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreebankLanguagePack.html" title="interface in edu.stanford.nlp.trees">TreebankLanguagePack</A> <B>tlp</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
emptyFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>emptyFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
aOverAFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>aOverAFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.BobChrisTreeNormalizer.AOverAFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/BobChrisTreeNormalizer.AOverAFilter.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.BobChrisTreeNormalizer.AOverAFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.BobChrisTreeNormalizer.EmptyFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/BobChrisTreeNormalizer.EmptyFilter.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.BobChrisTreeNormalizer.EmptyFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>8914098359495987617L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.CollinsHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/CollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.CollinsHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/AbstractCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">AbstractCollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8747319554557223437L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.Dependencies.DependentPuncTagRejectFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/Dependencies.DependentPuncTagRejectFilter.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.Dependencies.DependentPuncTagRejectFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7732189363171164852L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tagRejectFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>tagRejectFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.Dependencies.DependentPuncWordRejectFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/Dependencies.DependentPuncWordRejectFilter.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.Dependencies.DependentPuncWordRejectFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1166489968248785287L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
wordRejectFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>wordRejectFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.EnglishGrammaticalStructure"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/EnglishGrammaticalStructure.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.EnglishGrammaticalStructure</A> extends <A HREF="edu/stanford/nlp/trees/GrammaticalStructure.html" title="class in edu.stanford.nlp.trees">GrammaticalStructure</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1866362375001969402L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.GrammaticalRelation"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/GrammaticalRelation.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.GrammaticalRelation</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>892618003417550128L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
language</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/GrammaticalRelation.Language.html" title="enum in edu.stanford.nlp.trees">GrammaticalRelation.Language</A> <B>language</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
shortName</H3>
<PRE>
java.lang.String <B>shortName</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
longName</H3>
<PRE>
java.lang.String <B>longName</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
parent</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/GrammaticalRelation.html" title="class in edu.stanford.nlp.trees">GrammaticalRelation</A> <B>parent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
children</H3>
<PRE>
java.util.List&lt;E&gt; <B>children</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
sourcePattern</H3>
<PRE>
java.util.regex.Pattern <B>sourcePattern</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
targetPatterns</H3>
<PRE>
java.util.List&lt;E&gt; <B>targetPatterns</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
specific</H3>
<PRE>
java.lang.String <B>specific</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.GrammaticalStructure"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/GrammaticalStructure.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.GrammaticalStructure</A> extends <A HREF="edu/stanford/nlp/trees/TreeGraph.html" title="class in edu.stanford.nlp.trees">TreeGraph</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2286294455343892678L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
dependencies</H3>
<PRE>
java.util.Set&lt;E&gt; <B>dependencies</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
typedDependencies</H3>
<PRE>
java.util.List&lt;E&gt; <B>typedDependencies</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
allTypedDependencies</H3>
<PRE>
java.util.List&lt;E&gt; <B>allTypedDependencies</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
puncFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>puncFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.LabeledScoredTreeNode"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/LabeledScoredTreeNode.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.LabeledScoredTreeNode</A> extends <A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8992385140984593817L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
label</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A> <B>label</B></PRE>
<DL>
<DD>Label of the parse tree.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
score</H3>
<PRE>
double <B>score</B></PRE>
<DL>
<DD>Score of <code>TreeNode</code>
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
daughterTrees</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[] <B>daughterTrees</B></PRE>
<DL>
<DD>Daughters of the parse tree.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.LeftHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/LeftHeadFinder.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.LeftHeadFinder</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>8453889846239508208L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.ModCollinsHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/ModCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.ModCollinsHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/CollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">CollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5870387458902637256L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.NamedDependency"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/NamedDependency.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.NamedDependency</A> extends <A HREF="edu/stanford/nlp/trees/UnnamedDependency.html" title="class in edu.stanford.nlp.trees">UnnamedDependency</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-1635646451505721133L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
name</H3>
<PRE>
java.lang.Object <B>name</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/NPTmpRetainingTreeNormalizer.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.NPTmpRetainingTreeNormalizer</A> extends <A HREF="edu/stanford/nlp/trees/BobChrisTreeNormalizer.html" title="class in edu.stanford.nlp.trees">BobChrisTreeNormalizer</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>7548777133196579107L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
temporalAnnotation</H3>
<PRE>
int <B>temporalAnnotation</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
doSGappedStuff</H3>
<PRE>
boolean <B>doSGappedStuff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
leaveItAll</H3>
<PRE>
int <B>leaveItAll</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
doAdverbialNP</H3>
<PRE>
boolean <B>doAdverbialNP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
headFinder</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</A> <B>headFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.PennTreebankLanguagePack"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/PennTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.PennTreebankLanguagePack</A> extends <A HREF="edu/stanford/nlp/trees/AbstractTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees">AbstractTreebankLanguagePack</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>9081305982861675328L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.SemanticHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/SemanticHeadFinder.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.SemanticHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/ModCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">ModCollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5721799188009249808L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
verbalAuxiliaries</H3>
<PRE>
java.util.Set&lt;E&gt; <B>verbalAuxiliaries</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
copulars</H3>
<PRE>
java.util.Set&lt;E&gt; <B>copulars</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
passiveAuxiliaries</H3>
<PRE>
java.util.Set&lt;E&gt; <B>passiveAuxiliaries</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
verbalTags</H3>
<PRE>
java.util.Set&lt;E&gt; <B>verbalTags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
unambiguousAuxiliaryTags</H3>
<PRE>
java.util.Set&lt;E&gt; <B>unambiguousAuxiliaryTags</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.SimpleTree"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/SimpleTree.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.SimpleTree</A> extends <A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8075763706877132926L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
daughterTrees</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>[] <B>daughterTrees</B></PRE>
<DL>
<DD>Daughters of the parse tree.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.Tree"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.Tree</A> extends java.util.AbstractCollection&lt;<A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5441849457648722744L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.TreeGraph"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/TreeGraph.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.TreeGraph</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
root</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</A> <B>root</B></PRE>
<DL>
<DD>The root node of this treegraph.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
indexMap</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>indexMap</B></PRE>
<DL>
<DD>A map from arbitrary integer indices to nodes.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.TreeGraphNode"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.TreeGraphNode</A> extends <A HREF="edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5080098143617475328L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
label</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/CoreLabel.html" title="class in edu.stanford.nlp.ling">CoreLabel</A> <B>label</B></PRE>
<DL>
<DD>Label for this node.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
parent</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</A> <B>parent</B></PRE>
<DL>
<DD>Parent of this node.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
children</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</A>[] <B>children</B></PRE>
<DL>
<DD>Children of this node.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tg</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraph.html" title="class in edu.stanford.nlp.trees">TreeGraph</A> <B>tg</B></PRE>
<DL>
<DD>The <A HREF="edu/stanford/nlp/trees/TreeGraph.html" title="class in edu.stanford.nlp.trees"><CODE><code>TreeGraph</code></CODE></A> of which this
 node is part.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.TreeNormalizer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/TreeNormalizer.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.TreeNormalizer</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1540681875853883387L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.TypedDependency"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/TypedDependency.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.TypedDependency</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7690294213151279779L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
reln</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/GrammaticalRelation.html" title="class in edu.stanford.nlp.trees">GrammaticalRelation</A> <B>reln</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
gov</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</A> <B>gov</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dep</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</A> <B>dep</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
extra</H3>
<PRE>
boolean <B>extra</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.UnnamedConcreteDependency"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/UnnamedConcreteDependency.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.UnnamedConcreteDependency</A> extends <A HREF="edu/stanford/nlp/trees/UnnamedDependency.html" title="class in edu.stanford.nlp.trees">UnnamedDependency</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8836949694741145222L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
headIndex</H3>
<PRE>
int <B>headIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
depIndex</H3>
<PRE>
int <B>depIndex</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.UnnamedDependency"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/UnnamedDependency.html" title="class in edu.stanford.nlp.trees">edu.stanford.nlp.trees.UnnamedDependency</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-3768440215342256085L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
regentText</H3>
<PRE>
java.lang.String <B>regentText</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dependentText</H3>
<PRE>
java.lang.String <B>dependentText</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
regent</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A> <B>regent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
dependent</H3>
<PRE>
<A HREF="edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</A> <B>dependent</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.trees.international.pennchinese</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.BikelChineseHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/BikelChineseHeadFinder.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.BikelChineseHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/AbstractCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">AbstractCollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5445795668059315082L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.ChineseEnglishWordMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseEnglishWordMap.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.ChineseEnglishWordMap</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>7655332268578049993L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
normalized</H3>
<PRE>
boolean <B>normalized</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.ChineseGrammaticalStructure"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseGrammaticalStructure.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.ChineseGrammaticalStructure</A> extends <A HREF="edu/stanford/nlp/trees/GrammaticalStructure.html" title="class in edu.stanford.nlp.trees">GrammaticalStructure</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>8877651855167458256L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.ChineseHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseHeadFinder.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.ChineseHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/AbstractCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">AbstractCollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>6143632784691159283L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.ChineseSemanticHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseSemanticHeadFinder.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.ChineseSemanticHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseHeadFinder.html" title="class in edu.stanford.nlp.trees.international.pennchinese">ChineseHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2L

<P>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.ChineseTreebankLanguagePack"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/ChineseTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.ChineseTreebankLanguagePack</A> extends <A HREF="edu/stanford/nlp/trees/AbstractTreebankLanguagePack.html" title="class in edu.stanford.nlp.trees">AbstractTreebankLanguagePack</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5757403475523638802L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tf</H3>
<PRE>
<A HREF="edu/stanford/nlp/process/TokenizerFactory.html" title="interface in edu.stanford.nlp.process">TokenizerFactory</A>&lt;<A HREF="edu/stanford/nlp/process/TokenizerFactory.html" title="type parameter in TokenizerFactory">T</A>&gt; <B>tf</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.CTBErrorCorrectingTreeNormalizer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/CTBErrorCorrectingTreeNormalizer.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.CTBErrorCorrectingTreeNormalizer</A> extends <A HREF="edu/stanford/nlp/trees/BobChrisTreeNormalizer.html" title="class in edu.stanford.nlp.trees">BobChrisTreeNormalizer</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-8203853817025401845L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
tagExtender</H3>
<PRE>
<A HREF="edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A> <B>tagExtender</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitNPTMP</H3>
<PRE>
boolean <B>splitNPTMP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitPPTMP</H3>
<PRE>
boolean <B>splitPPTMP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
splitXPTMP</H3>
<PRE>
boolean <B>splitXPTMP</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
chineseEmptyFilter</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/Filter.html" title="interface in edu.stanford.nlp.util">Filter</A>&lt;<A HREF="edu/stanford/nlp/util/Filter.html" title="type parameter in Filter">T</A>&gt; <B>chineseEmptyFilter</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.international.pennchinese.SunJurafskyChineseHeadFinder"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/international/pennchinese/SunJurafskyChineseHeadFinder.html" title="class in edu.stanford.nlp.trees.international.pennchinese">edu.stanford.nlp.trees.international.pennchinese.SunJurafskyChineseHeadFinder</A> extends <A HREF="edu/stanford/nlp/trees/AbstractCollinsHeadFinder.html" title="class in edu.stanford.nlp.trees">AbstractCollinsHeadFinder</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7942375587642755210L

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.trees.tregex</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.trees.tregex.ParseException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/tregex/ParseException.html" title="class in edu.stanford.nlp.trees.tregex">edu.stanford.nlp.trees.tregex.ParseException</A> extends java.lang.Exception implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
currentToken</H3>
<PRE>
edu.stanford.nlp.trees.tregex.Token <B>currentToken</B></PRE>
<DL>
<DD>This is the last token that has been consumed successfully.  If
 this object has been created due to a parse error, the token
 followng this token will (therefore) be the first error token.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
expectedTokenSequences</H3>
<PRE>
int[][] <B>expectedTokenSequences</B></PRE>
<DL>
<DD>Each entry in this array is an array of integers.  Each array
 of integers represents a sequence of tokens (by their ordinal
 values) that is expected at this point of the parse.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tokenImage</H3>
<PRE>
java.lang.String[] <B>tokenImage</B></PRE>
<DL>
<DD>This is a reference to the "tokenImage" array of the generated
 parser within which the parse error occurred.  This array is
 defined in the generated ...Constants interface.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
eol</H3>
<PRE>
java.lang.String <B>eol</B></PRE>
<DL>
<DD>The end of line string for this machine.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.tregex.TregexParseException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/tregex/TregexParseException.html" title="class in edu.stanford.nlp.trees.tregex">edu.stanford.nlp.trees.tregex.TregexParseException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>

<P>
<A NAME="edu.stanford.nlp.trees.tregex.TregexPattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">edu.stanford.nlp.trees.tregex.TregexPattern</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5060298043763944913L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
neg</H3>
<PRE>
boolean <B>neg</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
opt</H3>
<PRE>
boolean <B>opt</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
patternString</H3>
<PRE>
java.lang.String <B>patternString</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.trees.tregex.tsurgeon</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.trees.tregex.tsurgeon.ParseException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/tregex/tsurgeon/ParseException.html" title="class in edu.stanford.nlp.trees.tregex.tsurgeon">edu.stanford.nlp.trees.tregex.tsurgeon.ParseException</A> extends java.lang.Exception implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
currentToken</H3>
<PRE>
edu.stanford.nlp.trees.tregex.tsurgeon.Token <B>currentToken</B></PRE>
<DL>
<DD>This is the last token that has been consumed successfully.  If
 this object has been created due to a parse error, the token
 followng this token will (therefore) be the first error token.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
expectedTokenSequences</H3>
<PRE>
int[][] <B>expectedTokenSequences</B></PRE>
<DL>
<DD>Each entry in this array is an array of integers.  Each array
 of integers represents a sequence of tokens (by their ordinal
 values) that is expected at this point of the parse.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
tokenImage</H3>
<PRE>
java.lang.String[] <B>tokenImage</B></PRE>
<DL>
<DD>This is a reference to the "tokenImage" array of the generated
 parser within which the parse error occurred.  This array is
 defined in the generated ...Constants interface.
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
eol</H3>
<PRE>
java.lang.String <B>eol</B></PRE>
<DL>
<DD>The end of line string for this machine.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.trees.tregex.tsurgeon.TsurgeonParseException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/trees/tregex/tsurgeon/TsurgeonParseException.html" title="class in edu.stanford.nlp.trees.tregex.tsurgeon">edu.stanford.nlp.trees.tregex.tsurgeon.TsurgeonParseException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<HR SIZE="4" NOSHADE>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="center"><FONT SIZE="+2">
<B>Package</B> <B>edu.stanford.nlp.util</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="edu.stanford.nlp.util.ArrayCoreMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/ArrayCoreMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.ArrayCoreMap</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="writeObject(java.io.ObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
private void <B>writeObject</B>(java.io.ObjectOutputStream&nbsp;out)
                  throws java.io.IOException</PRE>
<DL>
<DD>Overridden serialization method: compacts our map before writing.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - If IO error</DD>
</DL>
</DL>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
keys</H3>
<PRE>
java.lang.Class&lt;T&gt;[] <B>keys</B></PRE>
<DL>
<DD>Array of keys
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
values</H3>
<PRE>
java.lang.Object[] <B>values</B></PRE>
<DL>
<DD>Array of values
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
size</H3>
<PRE>
int <B>size</B></PRE>
<DL>
<DD>Total number of elements actually in keys,values
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.ArrayMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/ArrayMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.ArrayMap</A> extends java.util.AbstractMap&lt;<A HREF="edu/stanford/nlp/util/ArrayMap.html" title="type parameter in ArrayMap">K</A>,<A HREF="edu/stanford/nlp/util/ArrayMap.html" title="type parameter in ArrayMap">V</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
entryArray</H3>
<PRE>
edu.stanford.nlp.util.ArrayMap.Entry&lt;K,V&gt;[] <B>entryArray</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
capacity</H3>
<PRE>
int <B>capacity</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
size</H3>
<PRE>
int <B>size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
hashCodeCache</H3>
<PRE>
int <B>hashCodeCache</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.ArrayStringFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/ArrayStringFilter.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.ArrayStringFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
words</H3>
<PRE>
java.lang.String[] <B>words</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
length</H3>
<PRE>
int <B>length</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>3711321773145894069L

<P>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory.ArrayListFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.ArrayListFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory.ArrayListFactory</A> extends <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.ArrayListFactory.html" title="type parameter in CollectionFactory.ArrayListFactory">T</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory.HashSetFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.HashSetFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory.HashSetFactory</A> extends <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.HashSetFactory.html" title="type parameter in CollectionFactory.HashSetFactory">T</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-6268401669449458602L

<P>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory.LinkedListFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.LinkedListFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory.LinkedListFactory</A> extends <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.LinkedListFactory.html" title="type parameter in CollectionFactory.LinkedListFactory">T</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4236184979948498000L

<P>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory.SizedArrayListFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.SizedArrayListFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory.SizedArrayListFactory</A> extends <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.SizedArrayListFactory.html" title="type parameter in CollectionFactory.SizedArrayListFactory">T</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
defaultSize</H3>
<PRE>
int <B>defaultSize</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.CollectionFactory.TreeSetFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionFactory.TreeSetFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionFactory.TreeSetFactory</A> extends <A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.TreeSetFactory.html" title="type parameter in CollectionFactory.TreeSetFactory">T</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-3451920268219478134L

<P>

<P>
<A NAME="edu.stanford.nlp.util.CollectionValuedMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/CollectionValuedMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.CollectionValuedMap</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-9064664153962599076L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
cf</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="class in edu.stanford.nlp.util">CollectionFactory</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionFactory.html" title="type parameter in CollectionFactory">T</A>&gt; <B>cf</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
treatCollectionsAsImmutable</H3>
<PRE>
boolean <B>treatCollectionsAsImmutable</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mf</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>mf</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
emptyValue</H3>
<PRE>
java.util.Collection&lt;E&gt; <B>emptyValue</B></PRE>
<DL>
<DD>The empty collection to be returned when a <code>get</code> doesn't find
 the key. The collection returned should be empty, such as
 Collections.emptySet, for example.
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.DeltaCollectionValuedMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/DeltaCollectionValuedMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.DeltaCollectionValuedMap</A> extends <A HREF="edu/stanford/nlp/util/CollectionValuedMap.html" title="class in edu.stanford.nlp.util">CollectionValuedMap</A>&lt;<A HREF="edu/stanford/nlp/util/DeltaCollectionValuedMap.html" title="type parameter in DeltaCollectionValuedMap">K</A>,<A HREF="edu/stanford/nlp/util/DeltaCollectionValuedMap.html" title="type parameter in DeltaCollectionValuedMap">V</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
originalMap</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/CollectionValuedMap.html" title="class in edu.stanford.nlp.util">CollectionValuedMap</A>&lt;<A HREF="edu/stanford/nlp/util/CollectionValuedMap.html" title="type parameter in CollectionValuedMap">K</A>,<A HREF="edu/stanford/nlp/util/CollectionValuedMap.html" title="type parameter in CollectionValuedMap">V</A>&gt; <B>originalMap</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
deltaMap</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>deltaMap</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.Filters.ConjFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Filters.ConjFilter.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Filters.ConjFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
filters</H3>
<PRE>
java.util.List&lt;E&gt; <B>filters</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.Filters.DisjFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Filters.DisjFilter.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Filters.DisjFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
filters</H3>
<PRE>
java.util.List&lt;E&gt; <B>filters</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.Filters.RandomFilter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Filters.RandomFilter.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Filters.RandomFilter</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
random</H3>
<PRE>
java.util.Random <B>random</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
fraction</H3>
<PRE>
double <B>fraction</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.FixedPrioritiesPriorityQueue"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/FixedPrioritiesPriorityQueue.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.FixedPrioritiesPriorityQueue</A> extends java.util.AbstractSet&lt;<A HREF="edu/stanford/nlp/util/FixedPrioritiesPriorityQueue.html" title="type parameter in FixedPrioritiesPriorityQueue">E</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
size</H3>
<PRE>
int <B>size</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
capacity</H3>
<PRE>
int <B>capacity</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
elements</H3>
<PRE>
java.util.List&lt;E&gt; <B>elements</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
priorities</H3>
<PRE>
double[] <B>priorities</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.HashableCoreMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/HashableCoreMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.HashableCoreMap</A> extends <A HREF="edu/stanford/nlp/util/ArrayCoreMap.html" title="class in edu.stanford.nlp.util">ArrayCoreMap</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
immutableKeys</H3>
<PRE>
java.util.Set&lt;E&gt; <B>immutableKeys</B></PRE>
<DL>
<DD>Set of immutable keys
<P>
<DL>
</DL>
</DL>
<HR>
<H3>
hashcode</H3>
<PRE>
int <B>hashcode</B></PRE>
<DL>
<DD>Pre-computed hashcode
<P>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.HashableCoreMap.HashableCoreMapException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/HashableCoreMap.HashableCoreMapException.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.HashableCoreMap.HashableCoreMapException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<A NAME="edu.stanford.nlp.util.HashIndex"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/HashIndex.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.HashIndex</A> extends java.util.AbstractCollection&lt;<A HREF="edu/stanford/nlp/util/HashIndex.html" title="type parameter in HashIndex">E</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>5398562825928375260L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
objects</H3>
<PRE>
java.util.ArrayList&lt;E&gt; <B>objects</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
indexes</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>indexes</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
locked</H3>
<PRE>
boolean <B>locked</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
semaphore</H3>
<PRE>
java.util.concurrent.Semaphore <B>semaphore</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.IdentityHashSet"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IdentityHashSet.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IdentityHashSet</A> extends java.util.AbstractSet&lt;<A HREF="edu/stanford/nlp/util/IdentityHashSet.html" title="type parameter in IdentityHashSet">E</A>&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5024744406713321676L

<P>
<A NAME="serialized_methods"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialization Methods</B></FONT></TH>
</TR>
</TABLE>

<P>
<A NAME="readObject(java.io.ObjectInputStream)"><!-- --></A><H3>
readObject</H3>
<PRE>
private void <B>readObject</B>(java.io.ObjectInputStream&nbsp;s)
                 throws java.io.IOException,
                        java.lang.ClassNotFoundException</PRE>
<DL>
<DD>Deserialize this Object in a manner which is binary-compatible with
  the JDK.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE></DD>
</DL>
</DL>
<HR>
<A NAME="writeObject(java.io.ObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
private void <B>writeObject</B>(java.io.ObjectOutputStream&nbsp;s)
                  throws java.io.IOException</PRE>
<DL>
<DD>Serialize this Object in a manner which is binary-compatible with the
  JDK.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DD>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.Interval"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Interval.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Interval</A> extends <A HREF="edu/stanford/nlp/util/Pair.html" title="class in edu.stanford.nlp.util">Pair</A>&lt;<A HREF="edu/stanford/nlp/util/Interval.html" title="type parameter in Interval">E</A> extends java.lang.Comparable&lt;<A HREF="edu/stanford/nlp/util/Interval.html" title="type parameter in Interval">E</A>&gt;,<A HREF="edu/stanford/nlp/util/Interval.html" title="type parameter in Interval">E</A> extends java.lang.Comparable&lt;<A HREF="edu/stanford/nlp/util/Interval.html" title="type parameter in Interval">E</A>&gt;&gt; implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
flags</H3>
<PRE>
int <B>flags</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.IntPair"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IntPair.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IntPair</A> extends <A HREF="edu/stanford/nlp/util/IntTuple.html" title="class in edu.stanford.nlp.util">IntTuple</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<A NAME="edu.stanford.nlp.util.IntQuadruple"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IntQuadruple.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IntQuadruple</A> extends <A HREF="edu/stanford/nlp/util/IntTuple.html" title="class in edu.stanford.nlp.util">IntTuple</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>7154973101012473479L

<P>

<P>
<A NAME="edu.stanford.nlp.util.IntTriple"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IntTriple.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IntTriple</A> extends <A HREF="edu/stanford/nlp/util/IntTuple.html" title="class in edu.stanford.nlp.util">IntTuple</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-3744404627253652799L

<P>

<P>
<A NAME="edu.stanford.nlp.util.IntTuple"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IntTuple.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IntTuple</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>7266305463893511982L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
elements</H3>
<PRE>
int[] <B>elements</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.IntUni"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/IntUni.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.IntUni</A> extends <A HREF="edu/stanford/nlp/util/IntTuple.html" title="class in edu.stanford.nlp.util">IntTuple</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-7182556672628741200L

<P>

<P>
<A NAME="edu.stanford.nlp.util.LowercaseFunction"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/LowercaseFunction.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.LowercaseFunction</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<A NAME="edu.stanford.nlp.util.MapFactory"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.MapFactory</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>4529666940763477360L

<P>

<P>
<A NAME="edu.stanford.nlp.util.MetaClass.ClassCreationException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/MetaClass.ClassCreationException.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.MetaClass.ClassCreationException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5980065992461870357L

<P>

<P>
<A NAME="edu.stanford.nlp.util.MetaClass.ConstructorNotFoundException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/MetaClass.ConstructorNotFoundException.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.MetaClass.ConstructorNotFoundException</A> extends <A HREF="edu/stanford/nlp/util/MetaClass.ClassCreationException.html" title="class in edu.stanford.nlp.util">MetaClass.ClassCreationException</A> implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-5980065992461870357L

<P>

<P>
<A NAME="edu.stanford.nlp.util.MutableDouble"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/MutableDouble.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.MutableDouble</A> extends java.lang.Number implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>624465615824626762L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
d</H3>
<PRE>
double <B>d</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.MutableInteger"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/MutableInteger.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.MutableInteger</A> extends java.lang.Number implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>624465615824626762L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
i</H3>
<PRE>
int <B>i</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.Pair"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Pair.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Pair</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1360822168806852921L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
first</H3>
<PRE>
java.lang.Object <B>first</B></PRE>
<DL>
<DD>Direct access is deprecated.  Use first().
<P>
<DT><DD>&nbsp;<DL>
</DL>
</DL>
<HR>
<H3>
second</H3>
<PRE>
java.lang.Object <B>second</B></PRE>
<DL>
<DD>Direct access is deprecated.  Use second().
<P>
<DT><DD>&nbsp;<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.ReflectionLoading.ReflectionLoadingException"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/ReflectionLoading.ReflectionLoadingException.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.ReflectionLoading.ReflectionLoadingException</A> extends java.lang.RuntimeException implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-3324911744277952585L

<P>

<P>
<A NAME="edu.stanford.nlp.util.Triple"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/Triple.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.Triple</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>-4182871682751645440L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
first</H3>
<PRE>
java.lang.Object <B>first</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
second</H3>
<PRE>
java.lang.Object <B>second</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
third</H3>
<PRE>
java.lang.Object <B>third</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.TwoDimensionalMap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/TwoDimensionalMap.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.TwoDimensionalMap</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>2L

<P>
<A NAME="serializedForm"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Serialized Fields</B></FONT></TH>
</TR>
</TABLE>

<H3>
mf1</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>mf1</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
mf2</H3>
<PRE>
<A HREF="edu/stanford/nlp/util/MapFactory.html" title="class in edu.stanford.nlp.util">MapFactory</A>&lt;<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">K</A>,<A HREF="edu/stanford/nlp/util/MapFactory.html" title="type parameter in MapFactory">V</A>&gt; <B>mf2</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>
<H3>
map</H3>
<PRE>
java.util.Map&lt;K,V&gt; <B>map</B></PRE>
<DL>
<DL>
</DL>
</DL>

<P>
<A NAME="edu.stanford.nlp.util.UTF8EquivalenceFunction"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class <A HREF="edu/stanford/nlp/util/UTF8EquivalenceFunction.html" title="class in edu.stanford.nlp.util">edu.stanford.nlp.util.UTF8EquivalenceFunction</A> extends java.lang.Object implements Serializable</B></FONT></TH>
</TR>
</TABLE>

<P>
<B>serialVersionUID:&nbsp;</B>1L

<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?serialized-form.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="serialized-form.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT>
</BODY>
</HTML>
