<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_33) on Thu Jun 20 16:29:01 PDT 2013 -->
<TITLE>
TrainOptions (Stanford JavaNLP API)
</TITLE>

<META NAME="date" CONTENT="2013-06-20">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TrainOptions (Stanford JavaNLP API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TestOptions.html" title="class in edu.stanford.nlp.parser.lexparser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/stanford/nlp/parser/lexparser/TrainOptions.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TrainOptions.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.stanford.nlp.parser.lexparser</FONT>
<BR>
Class TrainOptions</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>edu.stanford.nlp.parser.lexparser.TrainOptions</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>TrainOptions</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
Non-language-specific options for training a grammar from a treebank.
 These options are not used at parsing time.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Dan Klein, Christopher Manning</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../../serialized-form.html#edu.stanford.nlp.parser.lexparser.TrainOptions">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser">TrainOptions.TransformMatrixType</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#basicCategoryTagsInDependencyGrammar">basicCategoryTagsInDependencyGrammar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where to use the basic or split tags in the dependency grammar</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#cheatPCFG">cheatPCFG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all test set trees to training data for PCFG.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#collinsPunc">collinsPunc</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promote/delete punctuation like Collins.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#compactGrammar">compactGrammar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to compact grammars as FSMs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#debugOutputSeconds">debugOutputSeconds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If larger than 0, the parser may choose to output debug information every X seconds</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_BATCH_SIZE">DEFAULT_BATCH_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, how many trees to use in one batch</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_DELTA_MARGIN">DEFAULT_DELTA_MARGIN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_DV_ITERATIONS">DEFAULT_DV_ITERATIONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, how many iterations to loop</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_K_BEST">DEFAULT_K_BEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, how many of the top K trees
 to analyze from the underlying parser</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_LEARNING_RATE">DEFAULT_LEARNING_RATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_QN_ITERATIONS_PER_BATCH">DEFAULT_QN_ITERATIONS_PER_BATCH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, how many iterations to loop
 for one batch of trees</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_REGCOST">DEFAULT_REGCOST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regularization constant</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_SCALING_FOR_INIT">DEFAULT_SCALING_FOR_INIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#DEFAULT_UNK_WORD">DEFAULT_UNK_WORD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#deleteSplitters">deleteSplitters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#deltaMargin">deltaMargin</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How much to penalize the wrong trees for how different they are
 from the gold tree when training</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#dvBatchSize">dvBatchSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#dvIterations">dvIterations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#dvKBest">dvKBest</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#dvSeed">dvSeed</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#dvSimplifiedModel">dvSimplifiedModel</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make the dv model as simple as possible</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#fractionBeforeUnseenCounting">fractionBeforeUnseenCounting</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start to aggregate signature-tag pairs only for words unseen in the first
 this fraction of the data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#gPA">gPA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This variable controls doing 2 levels of parent annotation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#HSEL_CUT">HSEL_CUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#hSelSplit">hSelSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#learningRate">learningRate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How fast to learn (can mean different things for different algorithms)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#leftRec">leftRec</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left edge is right-recursive (X << X)  Bad.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#leftToRight">leftToRight</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#lowercaseWordVectors">lowercaseWordVectors</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to lowercase word vectors</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#markFinalStates">markFinalStates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to mark final states in binarized grammar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#markovFactor">markovFactor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether to do "horizontal Markovization" (as in ACL 2003 paper).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#markovOrder">markovOrder</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#markUnary">markUnary</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mark all unary nodes specially.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#markUnaryTags">markUnaryTags</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mark POS tags which are the sole member of their phrasal constituent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#maxTrainTimeSeconds">maxTrainTimeSeconds</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#noRebinarization">noRebinarization</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When binarizing trees, don't binarize trees with two children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#noTagSplit">noTagSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#openClassTypesThreshold">openClassTypesThreshold</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A POS tag has to have been attributed to more than this number of word
 types before it is regarded as an open-class tag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#PA">PA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This variable controls doing parent annotation of phrasal nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#postGPA">postGPA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#postPA">postPA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#postSplitters">postSplitters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#postSplitWithBaseCategory">postSplitWithBaseCategory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether, in post-splitting of categories, nodes are annotated with the
  (grand)parent's base category or with its complete subcategorized
  category.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#predictSplits">predictSplits</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use the method reported by Berkeley for splitting and recombining
 states.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#preTransformer">preTransformer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A transformer to use on the training data before any other
 processing step.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.io.PrintWriter</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printAnnotatedPW">printAnnotatedPW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printAnnotatedRuleCounts">printAnnotatedRuleCounts</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printAnnotatedStateCounts">printAnnotatedStateCounts</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.io.PrintWriter</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printBinarizedPW">printBinarizedPW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printStates">printStates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printTreeTransformations">printTreeTransformations</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just for debugging: check that your tree transforms work correctly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#qnEstimates">qnEstimates</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, how many estimates to keep
 for the qn approximation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#qnIterationsPerBatch">qnIterationsPerBatch</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#qnTolerance">qnTolerance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When training the DV parsing method, the tolerance to use if we
 want to stop qn early</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#regCost">regCost</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#rightRec">rightRec</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right edge is right-recursive (X << X) Bad.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#ruleDiscount">ruleDiscount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discounts the count of BinaryRule's (only, apparently) in training data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#ruleSmoothing">ruleSmoothing</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables linear rule smoothing during grammar extraction
 but before grammar compaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#ruleSmoothingAlpha">ruleSmoothingAlpha</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#scalingForInit">scalingForInit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How much to scale certain parameters when initializing models.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#selectivePostSplit">selectivePostSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#selectivePostSplitCutOff">selectivePostSplitCutOff</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#selectiveSplit">selectiveSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only split the "common high KL divergence" parent categories....</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#selectiveSplitCutOff">selectiveSplitCutOff</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#simpleBinarizedLabels">simpleBinarizedLabels</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When binarizing trees, don't annotate the labels with anything</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#sisterAnnotate">sisterAnnotate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selective Sister annotation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#sisterSplitters">sisterSplitters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#smoothing">smoothing</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TODO wsg2011: This is the old grammar smoothing parameter that no
 longer does anything in the parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#splitCount">splitCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If we are predicting splits, we loop this many times</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#splitPrePreT">splitPrePreT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mark all pre-preterminals (also does splitBaseNP: don't need both)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#splitRecombineRate">splitRecombineRate</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If we are predicting splits, we recombine states at this rate every loop</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#splitters">splitters</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the splitter strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#taggedFiles">taggedFiles</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A set of files to use as extra information in the lexicon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#tagPA">tagPA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parent annotation on tags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#tagSelectivePostSplit">tagSelectivePostSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#tagSelectivePostSplitCutOff">tagSelectivePostSplitCutOff</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#tagSelectiveSplit">tagSelectiveSplit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Do parent annotation on tags selectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#tagSelectiveSplitCutOff">tagSelectiveSplitCutOff</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#trainingThreads">trainingThreads</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the training algorithm allows for parallelization, how many
 threads to use</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#trainLengthLimit">trainLengthLimit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#trainTreeFile">trainTreeFile</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser">TrainOptions.TransformMatrixType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#transformMatrixType">transformMatrixType</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownCapsVector">unknownCapsVector</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to build an unknown word vector for words with caps in them</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownChineseNumberVector">unknownChineseNumberVector</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to build an unknown word vector to match Chinese numbers</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownChinesePercentVector">unknownChinesePercentVector</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to build an unknown word vector to match Chinese percentages</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownChineseYearVector">unknownChineseYearVector</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to build an unknown word vector to match Chinese years</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownDashedWordVectors">unknownDashedWordVectors</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to handle unknown dashed words by taking the last part</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unknownNumberVector">unknownNumberVector</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whether or not to build an unknown word vector specifically for numbers</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#unkWord">unkWord</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some models will use external data sources which contain
 information about unknown words.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#useContextWords">useContextWords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#TrainOptions()">TrainOptions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#compactGrammar()">compactGrammar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#display()">display</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#outsideFactor()">outsideFactor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If true, declare early -- leave this on except maybe with markov on.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#printTrainTree(java.io.PrintWriter, java.lang.String, edu.stanford.nlp.trees.Tree)">printTrainTree</A></B>(java.io.PrintWriter&nbsp;pw,
               java.lang.String&nbsp;message,
               <A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="trainTreeFile"><!-- --></A><H3>
trainTreeFile</H3>
<PRE>
public java.lang.String <B>trainTreeFile</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="trainLengthLimit"><!-- --></A><H3>
trainLengthLimit</H3>
<PRE>
public int <B>trainLengthLimit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="cheatPCFG"><!-- --></A><H3>
cheatPCFG</H3>
<PRE>
public boolean <B>cheatPCFG</B></PRE>
<DL>
<DD>Add all test set trees to training data for PCFG.
  (Currently only supported in FactoredParser main.)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="markovFactor"><!-- --></A><H3>
markovFactor</H3>
<PRE>
public boolean <B>markovFactor</B></PRE>
<DL>
<DD>Whether to do "horizontal Markovization" (as in ACL 2003 paper).
  False means regular PCFG expansions.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="markovOrder"><!-- --></A><H3>
markovOrder</H3>
<PRE>
public int <B>markovOrder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="hSelSplit"><!-- --></A><H3>
hSelSplit</H3>
<PRE>
public boolean <B>hSelSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="HSEL_CUT"><!-- --></A><H3>
HSEL_CUT</H3>
<PRE>
public int <B>HSEL_CUT</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="markFinalStates"><!-- --></A><H3>
markFinalStates</H3>
<PRE>
public boolean <B>markFinalStates</B></PRE>
<DL>
<DD>Whether or not to mark final states in binarized grammar.
  This must be off to get most value out of grammar compaction.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="openClassTypesThreshold"><!-- --></A><H3>
openClassTypesThreshold</H3>
<PRE>
public int <B>openClassTypesThreshold</B></PRE>
<DL>
<DD>A POS tag has to have been attributed to more than this number of word
 types before it is regarded as an open-class tag.  Unknown words will
 only possibly be tagged as open-class tags (unless flexiTag is on).
 If flexiTag is on, unknown words will be able to be tagged any POS for
 which the unseenMap has nonzero count (that is, the tag was seen for
 a new word after unseen signature counting was started).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="fractionBeforeUnseenCounting"><!-- --></A><H3>
fractionBeforeUnseenCounting</H3>
<PRE>
public double <B>fractionBeforeUnseenCounting</B></PRE>
<DL>
<DD>Start to aggregate signature-tag pairs only for words unseen in the first
 this fraction of the data.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="PA"><!-- --></A><H3>
PA</H3>
<PRE>
public boolean <B>PA</B></PRE>
<DL>
<DD>This variable controls doing parent annotation of phrasal nodes.  Good.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="gPA"><!-- --></A><H3>
gPA</H3>
<PRE>
public boolean <B>gPA</B></PRE>
<DL>
<DD>This variable controls doing 2 levels of parent annotation.  Bad.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="postPA"><!-- --></A><H3>
postPA</H3>
<PRE>
public boolean <B>postPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="postGPA"><!-- --></A><H3>
postGPA</H3>
<PRE>
public boolean <B>postGPA</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectiveSplit"><!-- --></A><H3>
selectiveSplit</H3>
<PRE>
public boolean <B>selectiveSplit</B></PRE>
<DL>
<DD>Only split the "common high KL divergence" parent categories.... Good.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectiveSplitCutOff"><!-- --></A><H3>
selectiveSplitCutOff</H3>
<PRE>
public double <B>selectiveSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectivePostSplit"><!-- --></A><H3>
selectivePostSplit</H3>
<PRE>
public boolean <B>selectivePostSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectivePostSplitCutOff"><!-- --></A><H3>
selectivePostSplitCutOff</H3>
<PRE>
public double <B>selectivePostSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="postSplitWithBaseCategory"><!-- --></A><H3>
postSplitWithBaseCategory</H3>
<PRE>
public boolean <B>postSplitWithBaseCategory</B></PRE>
<DL>
<DD>Whether, in post-splitting of categories, nodes are annotated with the
  (grand)parent's base category or with its complete subcategorized
  category.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="sisterAnnotate"><!-- --></A><H3>
sisterAnnotate</H3>
<PRE>
public boolean <B>sisterAnnotate</B></PRE>
<DL>
<DD>Selective Sister annotation.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="sisterSplitters"><!-- --></A><H3>
sisterSplitters</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>sisterSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="markUnary"><!-- --></A><H3>
markUnary</H3>
<PRE>
public int <B>markUnary</B></PRE>
<DL>
<DD>Mark all unary nodes specially.  Good for just PCFG. Bad for factored.
 markUnary affects phrasal nodes. A value of 0 means to do nothing;
 a value of 1 means to mark the parent (higher) node of a unary rewrite.
 A value of 2 means to mark the child (lower) node of a unary rewrie.
 Values of 1 and 2 only apply if the child (lower) node is phrasal.
 (A value of 1 is better than 2 in combos.)  A value of 1 corresponds
 to the old boolean -unary flag.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="markUnaryTags"><!-- --></A><H3>
markUnaryTags</H3>
<PRE>
public boolean <B>markUnaryTags</B></PRE>
<DL>
<DD>Mark POS tags which are the sole member of their phrasal constituent.
  This is like markUnary=2, applied to POS tags.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="splitPrePreT"><!-- --></A><H3>
splitPrePreT</H3>
<PRE>
public boolean <B>splitPrePreT</B></PRE>
<DL>
<DD>Mark all pre-preterminals (also does splitBaseNP: don't need both)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tagPA"><!-- --></A><H3>
tagPA</H3>
<PRE>
public boolean <B>tagPA</B></PRE>
<DL>
<DD>Parent annotation on tags.  Good (for PCFG?)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tagSelectiveSplit"><!-- --></A><H3>
tagSelectiveSplit</H3>
<PRE>
public boolean <B>tagSelectiveSplit</B></PRE>
<DL>
<DD>Do parent annotation on tags selectively.  Neutral, but less splits.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tagSelectiveSplitCutOff"><!-- --></A><H3>
tagSelectiveSplitCutOff</H3>
<PRE>
public double <B>tagSelectiveSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="tagSelectivePostSplit"><!-- --></A><H3>
tagSelectivePostSplit</H3>
<PRE>
public boolean <B>tagSelectivePostSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="tagSelectivePostSplitCutOff"><!-- --></A><H3>
tagSelectivePostSplitCutOff</H3>
<PRE>
public double <B>tagSelectivePostSplitCutOff</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="rightRec"><!-- --></A><H3>
rightRec</H3>
<PRE>
public boolean <B>rightRec</B></PRE>
<DL>
<DD>Right edge is right-recursive (X << X) Bad. (NP only is good)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="leftRec"><!-- --></A><H3>
leftRec</H3>
<PRE>
public boolean <B>leftRec</B></PRE>
<DL>
<DD>Left edge is right-recursive (X << X)  Bad.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="collinsPunc"><!-- --></A><H3>
collinsPunc</H3>
<PRE>
public boolean <B>collinsPunc</B></PRE>
<DL>
<DD>Promote/delete punctuation like Collins.  Bad (!)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="splitters"><!-- --></A><H3>
splitters</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>splitters</B></PRE>
<DL>
<DD>Set the splitter strings.  These are a set of parent and/or grandparent
 annotated categories which should be split off.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="postSplitters"><!-- --></A><H3>
postSplitters</H3>
<PRE>
public java.util.Set <B>postSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="deleteSplitters"><!-- --></A><H3>
deleteSplitters</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>deleteSplitters</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="printTreeTransformations"><!-- --></A><H3>
printTreeTransformations</H3>
<PRE>
public int <B>printTreeTransformations</B></PRE>
<DL>
<DD>Just for debugging: check that your tree transforms work correctly.  This
 will print the transformations of the first printTreeTransformations trees.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="printAnnotatedPW"><!-- --></A><H3>
printAnnotatedPW</H3>
<PRE>
public java.io.PrintWriter <B>printAnnotatedPW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="printBinarizedPW"><!-- --></A><H3>
printBinarizedPW</H3>
<PRE>
public java.io.PrintWriter <B>printBinarizedPW</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="printStates"><!-- --></A><H3>
printStates</H3>
<PRE>
public boolean <B>printStates</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="compactGrammar"><!-- --></A><H3>
compactGrammar</H3>
<PRE>
public int <B>compactGrammar</B></PRE>
<DL>
<DD>How to compact grammars as FSMs.
  0 = no compaction [uses makeSyntheticLabel1],
  1 = no compaction but use label names that wrap from right to left in binarization [uses makeSyntheticLabel2],
  2 = wrapping labels and materialize unary at top rewriting passive to active,
  3 = ExactGrammarCompactor,
  4 = LossyGrammarCompactor,
  5 = CategoryMergingGrammarCompactor.
  (May 2007 CDM note: options 4 and 5 don't seem to be functioning sensibly.  0, 1, and 3
  seem to be the 'good' options. 2 is only useful as input to 3.  There seems to be
  no reason not to use 0, despite the default.)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="leftToRight"><!-- --></A><H3>
leftToRight</H3>
<PRE>
public boolean <B>leftToRight</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="noTagSplit"><!-- --></A><H3>
noTagSplit</H3>
<PRE>
public boolean <B>noTagSplit</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="ruleSmoothing"><!-- --></A><H3>
ruleSmoothing</H3>
<PRE>
public boolean <B>ruleSmoothing</B></PRE>
<DL>
<DD>Enables linear rule smoothing during grammar extraction
 but before grammar compaction. The alpha term is the same
 as that described in Petrov et al. (2006), and has range [0,1].
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="ruleSmoothingAlpha"><!-- --></A><H3>
ruleSmoothingAlpha</H3>
<PRE>
public double <B>ruleSmoothingAlpha</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="smoothing"><!-- --></A><H3>
smoothing</H3>
<PRE>
public boolean <B>smoothing</B></PRE>
<DL>
<DD>TODO wsg2011: This is the old grammar smoothing parameter that no
 longer does anything in the parser. It should be removed.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="ruleDiscount"><!-- --></A><H3>
ruleDiscount</H3>
<PRE>
public double <B>ruleDiscount</B></PRE>
<DL>
<DD>Discounts the count of BinaryRule's (only, apparently) in training data.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="printAnnotatedRuleCounts"><!-- --></A><H3>
printAnnotatedRuleCounts</H3>
<PRE>
public boolean <B>printAnnotatedRuleCounts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="printAnnotatedStateCounts"><!-- --></A><H3>
printAnnotatedStateCounts</H3>
<PRE>
public boolean <B>printAnnotatedStateCounts</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="basicCategoryTagsInDependencyGrammar"><!-- --></A><H3>
basicCategoryTagsInDependencyGrammar</H3>
<PRE>
public boolean <B>basicCategoryTagsInDependencyGrammar</B></PRE>
<DL>
<DD>Where to use the basic or split tags in the dependency grammar
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="preTransformer"><!-- --></A><H3>
preTransformer</H3>
<PRE>
public <A HREF="../../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</A> <B>preTransformer</B></PRE>
<DL>
<DD>A transformer to use on the training data before any other
 processing step.  This is specified by using the -preTransformer
 flag when training the parser.  A comma separated list of classes
 will be turned into a CompositeTransformer.  This can be used to
 strip subcategories, to run a tsurgeon pattern, or any number of
 other useful operations.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="taggedFiles"><!-- --></A><H3>
taggedFiles</H3>
<PRE>
public java.lang.String <B>taggedFiles</B></PRE>
<DL>
<DD>A set of files to use as extra information in the lexicon.  This
 can provide tagged words which are not part of trees
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="predictSplits"><!-- --></A><H3>
predictSplits</H3>
<PRE>
public boolean <B>predictSplits</B></PRE>
<DL>
<DD>Use the method reported by Berkeley for splitting and recombining
 states.  This is an experimental and still in development
 reimplementation of that work.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="splitCount"><!-- --></A><H3>
splitCount</H3>
<PRE>
public int <B>splitCount</B></PRE>
<DL>
<DD>If we are predicting splits, we loop this many times
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="splitRecombineRate"><!-- --></A><H3>
splitRecombineRate</H3>
<PRE>
public double <B>splitRecombineRate</B></PRE>
<DL>
<DD>If we are predicting splits, we recombine states at this rate every loop
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="simpleBinarizedLabels"><!-- --></A><H3>
simpleBinarizedLabels</H3>
<PRE>
public boolean <B>simpleBinarizedLabels</B></PRE>
<DL>
<DD>When binarizing trees, don't annotate the labels with anything
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="noRebinarization"><!-- --></A><H3>
noRebinarization</H3>
<PRE>
public boolean <B>noRebinarization</B></PRE>
<DL>
<DD>When binarizing trees, don't binarize trees with two children.
 Only applies when using inside markov binarization for now.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="trainingThreads"><!-- --></A><H3>
trainingThreads</H3>
<PRE>
public int <B>trainingThreads</B></PRE>
<DL>
<DD>If the training algorithm allows for parallelization, how many
 threads to use
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_K_BEST"><!-- --></A><H3>
DEFAULT_K_BEST</H3>
<PRE>
public static final int <B>DEFAULT_K_BEST</B></PRE>
<DL>
<DD>When training the DV parsing method, how many of the top K trees
 to analyze from the underlying parser
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_K_BEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="dvKBest"><!-- --></A><H3>
dvKBest</H3>
<PRE>
public int <B>dvKBest</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_DV_ITERATIONS"><!-- --></A><H3>
DEFAULT_DV_ITERATIONS</H3>
<PRE>
public static final int <B>DEFAULT_DV_ITERATIONS</B></PRE>
<DL>
<DD>When training the DV parsing method, how many iterations to loop
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_DV_ITERATIONS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="dvIterations"><!-- --></A><H3>
dvIterations</H3>
<PRE>
public int <B>dvIterations</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_BATCH_SIZE"><!-- --></A><H3>
DEFAULT_BATCH_SIZE</H3>
<PRE>
public static final int <B>DEFAULT_BATCH_SIZE</B></PRE>
<DL>
<DD>When training the DV parsing method, how many trees to use in one batch
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_BATCH_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="dvBatchSize"><!-- --></A><H3>
dvBatchSize</H3>
<PRE>
public int <B>dvBatchSize</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_REGCOST"><!-- --></A><H3>
DEFAULT_REGCOST</H3>
<PRE>
public static final double <B>DEFAULT_REGCOST</B></PRE>
<DL>
<DD>regularization constant
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_REGCOST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="regCost"><!-- --></A><H3>
regCost</H3>
<PRE>
public double <B>regCost</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_QN_ITERATIONS_PER_BATCH"><!-- --></A><H3>
DEFAULT_QN_ITERATIONS_PER_BATCH</H3>
<PRE>
public static final int <B>DEFAULT_QN_ITERATIONS_PER_BATCH</B></PRE>
<DL>
<DD>When training the DV parsing method, how many iterations to loop
 for one batch of trees
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_QN_ITERATIONS_PER_BATCH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="qnIterationsPerBatch"><!-- --></A><H3>
qnIterationsPerBatch</H3>
<PRE>
public int <B>qnIterationsPerBatch</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="qnEstimates"><!-- --></A><H3>
qnEstimates</H3>
<PRE>
public int <B>qnEstimates</B></PRE>
<DL>
<DD>When training the DV parsing method, how many estimates to keep
 for the qn approximation.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="qnTolerance"><!-- --></A><H3>
qnTolerance</H3>
<PRE>
public double <B>qnTolerance</B></PRE>
<DL>
<DD>When training the DV parsing method, the tolerance to use if we
 want to stop qn early
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="debugOutputSeconds"><!-- --></A><H3>
debugOutputSeconds</H3>
<PRE>
public int <B>debugOutputSeconds</B></PRE>
<DL>
<DD>If larger than 0, the parser may choose to output debug information every X seconds
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="dvSeed"><!-- --></A><H3>
dvSeed</H3>
<PRE>
public long <B>dvSeed</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_LEARNING_RATE"><!-- --></A><H3>
DEFAULT_LEARNING_RATE</H3>
<PRE>
public static final double <B>DEFAULT_LEARNING_RATE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_LEARNING_RATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="learningRate"><!-- --></A><H3>
learningRate</H3>
<PRE>
public double <B>learningRate</B></PRE>
<DL>
<DD>How fast to learn (can mean different things for different algorithms)
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_DELTA_MARGIN"><!-- --></A><H3>
DEFAULT_DELTA_MARGIN</H3>
<PRE>
public static final double <B>DEFAULT_DELTA_MARGIN</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_DELTA_MARGIN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="deltaMargin"><!-- --></A><H3>
deltaMargin</H3>
<PRE>
public double <B>deltaMargin</B></PRE>
<DL>
<DD>How much to penalize the wrong trees for how different they are
 from the gold tree when training
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownNumberVector"><!-- --></A><H3>
unknownNumberVector</H3>
<PRE>
public boolean <B>unknownNumberVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector specifically for numbers
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownDashedWordVectors"><!-- --></A><H3>
unknownDashedWordVectors</H3>
<PRE>
public boolean <B>unknownDashedWordVectors</B></PRE>
<DL>
<DD>Whether or not to handle unknown dashed words by taking the last part
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownCapsVector"><!-- --></A><H3>
unknownCapsVector</H3>
<PRE>
public boolean <B>unknownCapsVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector for words with caps in them
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="dvSimplifiedModel"><!-- --></A><H3>
dvSimplifiedModel</H3>
<PRE>
public boolean <B>dvSimplifiedModel</B></PRE>
<DL>
<DD>Make the dv model as simple as possible
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownChineseYearVector"><!-- --></A><H3>
unknownChineseYearVector</H3>
<PRE>
public boolean <B>unknownChineseYearVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese years
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownChineseNumberVector"><!-- --></A><H3>
unknownChineseNumberVector</H3>
<PRE>
public boolean <B>unknownChineseNumberVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese numbers
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="unknownChinesePercentVector"><!-- --></A><H3>
unknownChinesePercentVector</H3>
<PRE>
public boolean <B>unknownChinesePercentVector</B></PRE>
<DL>
<DD>Whether or not to build an unknown word vector to match Chinese percentages
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_SCALING_FOR_INIT"><!-- --></A><H3>
DEFAULT_SCALING_FOR_INIT</H3>
<PRE>
public static final double <B>DEFAULT_SCALING_FOR_INIT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_SCALING_FOR_INIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="scalingForInit"><!-- --></A><H3>
scalingForInit</H3>
<PRE>
public double <B>scalingForInit</B></PRE>
<DL>
<DD>How much to scale certain parameters when initializing models.
 For example, the DVParser uses this to rescale its initial
 matrices.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxTrainTimeSeconds"><!-- --></A><H3>
maxTrainTimeSeconds</H3>
<PRE>
public int <B>maxTrainTimeSeconds</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="DEFAULT_UNK_WORD"><!-- --></A><H3>
DEFAULT_UNK_WORD</H3>
<PRE>
public static final java.lang.String <B>DEFAULT_UNK_WORD</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#edu.stanford.nlp.parser.lexparser.TrainOptions.DEFAULT_UNK_WORD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="unkWord"><!-- --></A><H3>
unkWord</H3>
<PRE>
public java.lang.String <B>unkWord</B></PRE>
<DL>
<DD>Some models will use external data sources which contain
 information about unknown words.  This variable is a way to
 provide the name of the unknown word in the external data source.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lowercaseWordVectors"><!-- --></A><H3>
lowercaseWordVectors</H3>
<PRE>
public boolean <B>lowercaseWordVectors</B></PRE>
<DL>
<DD>Whether or not to lowercase word vectors
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="transformMatrixType"><!-- --></A><H3>
transformMatrixType</H3>
<PRE>
public <A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser">TrainOptions.TransformMatrixType</A> <B>transformMatrixType</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="useContextWords"><!-- --></A><H3>
useContextWords</H3>
<PRE>
public boolean <B>useContextWords</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TrainOptions()"><!-- --></A><H3>
TrainOptions</H3>
<PRE>
public <B>TrainOptions</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="outsideFactor()"><!-- --></A><H3>
outsideFactor</H3>
<PRE>
public boolean <B>outsideFactor</B>()</PRE>
<DL>
<DD>If true, declare early -- leave this on except maybe with markov on.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Whether to do outside factorization in binarization of the grammar</DL>
</DD>
</DL>
<HR>

<A NAME="compactGrammar()"><!-- --></A><H3>
compactGrammar</H3>
<PRE>
public int <B>compactGrammar</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="display()"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printTrainTree(java.io.PrintWriter, java.lang.String, edu.stanford.nlp.trees.Tree)"><!-- --></A><H3>
printTrainTree</H3>
<PRE>
public static void <B>printTrainTree</B>(java.io.PrintWriter&nbsp;pw,
                                  java.lang.String&nbsp;message,
                                  <A HREF="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</A>&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TestOptions.html" title="class in edu.stanford.nlp.parser.lexparser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/stanford/nlp/parser/lexparser/TrainOptions.TransformMatrixType.html" title="enum in edu.stanford.nlp.parser.lexparser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?edu/stanford/nlp/parser/lexparser/TrainOptions.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TrainOptions.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT>
</BODY>
</HTML>
